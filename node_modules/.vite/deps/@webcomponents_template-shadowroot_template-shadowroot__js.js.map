{
  "version": 3,
  "sources": ["../../@webcomponents/template-shadowroot/src/_implementation/feature_detect.ts", "../../@webcomponents/template-shadowroot/src/_implementation/util.ts", "../../@webcomponents/template-shadowroot/src/_implementation/manual_walk.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// lib.dom.ts is out of date, so declare our own parseFromString here.\ninterface DOMParser {\n  parseFromString(string: string, type: DOMParserSupportedType, options?: {\n    includeShadowRoots: boolean;\n  }): Document;\n}\n\n// This isn't ideal. Setting .innerHTML is not compatible with some\n// TrustedTypes CSP policies. Discussion at:\n//     https://github.com/mfreed7/declarative-shadow-dom/issues/3\nlet hasNative: boolean|undefined;\nexport function hasNativeDeclarativeShadowRoots(): boolean {\n  if (hasNative === undefined) {\n    const html = `<div><template shadowrootmode=\"open\"></template></div>`;\n    const fragment = (new DOMParser() as DOMParser).parseFromString(html, 'text/html', {\n      includeShadowRoots: true\n    });\n    hasNative = !!fragment.querySelector('div')?.shadowRoot;\n  }\n  return hasNative;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport const hasNoParentElement =\n    (e: Element|DocumentFragment): e is DocumentFragment =>\n        e.parentElement === null;\nexport const isTemplate = (e: Node): e is HTMLTemplateElement =>\n    (e as Partial<Element>).tagName === 'TEMPLATE';\nexport const isElement = (e: Node): e is HTMLElement =>\n    e.nodeType === Node.ELEMENT_NODE;\n", "/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {hasNativeDeclarativeShadowRoots} from './feature_detect.js';\nimport {hasNoParentElement, isElement, isTemplate} from './util.js';\n\n/*\n * Traverses the DOM to find all <template> elements with a `shadowrootmode`\n * attribute and move their content into a ShadowRoot on their parent element.\n *\n * This processing is done bottom up so that when top-level <template>\n * elements are hydrated, their contents are already hydrated and in the\n * final correct structure of elements and shadow roots.\n */\nexport const hydrateShadowRoots = (root: ParentNode) => {\n  if (hasNativeDeclarativeShadowRoots()) {\n    return;  // nothing to do\n  }\n\n  // Approaches to try and benchmark:\n  //  - manual walk (current implementation)\n  //  - querySelectorAll\n  //  - TreeWalker\n\n  // Stack of nested templates that we're currently processing. Use to\n  // remember how to get from a <template>.content DocumentFragment back to\n  // its owner <template>\n  const templateStack: Array<HTMLTemplateElement> = [];\n\n  let currentNode: Element|DocumentFragment|null = root.firstElementChild;\n\n  // The outer loop traverses down, looking for <template shadowrootmode>\n  // elements. The inner loop traverses back up, hydrating them in a postorder\n  // traversal.\n  while (currentNode !== root && currentNode !== null) {\n    if (isTemplate(currentNode)) {\n      templateStack.push(currentNode);\n      currentNode = currentNode.content;\n    } else if (currentNode.firstElementChild !== null) {\n      // Traverse down\n      currentNode = currentNode.firstElementChild;\n    } else if (\n        isElement(currentNode) && currentNode.nextElementSibling !== null) {\n      // Element is empty, but has a next sibling. Traverse that.\n      currentNode = currentNode.nextElementSibling;\n    } else {\n      // Element is empty and the last child. Traverse to next aunt/grandaunt.\n\n      // Store templates we hydrate for one loop so that we can remove them\n      // *after* traversing to their successor.\n      let template: HTMLTemplateElement|undefined;\n\n      while (currentNode !== root && currentNode !== null) {\n        if (hasNoParentElement(currentNode)) {\n          // We must be at a <template>'s content fragment.\n          template = templateStack.pop()!;\n          const host = template.parentElement!;\n          const mode = template.getAttribute('shadowrootmode');\n          currentNode = template;\n          if (mode === 'open' || mode === 'closed') {\n            const delegatesFocus =\n                template.hasAttribute('shadowrootdelegatesfocus');\n            try {\n              const shadow = host.attachShadow({mode, delegatesFocus});\n              shadow.append(template.content);\n            } catch {\n              // there was already a shadow root.\n              // TODO(rictic): log an error event?\n            }\n          } else {\n            template = undefined;\n          }\n        } else {\n          const nextSibling: Element|null|undefined =\n              currentNode.nextElementSibling;\n          if (nextSibling != null) {\n            currentNode = nextSibling;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          const nextAunt: Element|null|undefined =\n              currentNode.parentElement?.nextElementSibling;\n          if (nextAunt != null) {\n            currentNode = nextAunt;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          currentNode = currentNode.parentElement;\n          if (template !== undefined) {\n            template.parentElement!.removeChild(template);\n            template = undefined;\n          }\n        }\n      }\n    }\n  }\n};\n"],
  "mappings": ";;;AAgBA,IAAI;AACE,SAAU,kCAA+B;;AAC7C,MAAI,cAAc,QAAW;AAC3B,UAAM,OAAO;AACb,UAAM,WAAY,IAAI,UAAS,EAAiB,gBAAgB,MAAM,aAAa;MACjF,oBAAoB;KACrB;AACD,gBAAY,CAAC,GAAC,KAAA,SAAS,cAAc,KAAK,OAAC,QAAA,OAAA,SAAA,SAAA,GAAE;;AAE/C,SAAO;AACT;;;ACpBO,IAAM,qBACT,CAAC,MACG,EAAE,kBAAkB;AACrB,IAAM,aAAa,CAAC,MACtB,EAAuB,YAAY;AACjC,IAAM,YAAY,CAAC,MACtB,EAAE,aAAa,KAAK;;;ACKjB,IAAM,qBAAqB,CAAC,SAAoB;;AACrD,MAAI,gCAA+B,GAAI;AACrC;;AAWF,QAAM,gBAA4C,CAAA;AAElD,MAAI,cAA6C,KAAK;AAKtD,SAAO,gBAAgB,QAAQ,gBAAgB,MAAM;AACnD,QAAI,WAAW,WAAW,GAAG;AAC3B,oBAAc,KAAK,WAAW;AAC9B,oBAAc,YAAY;eACjB,YAAY,sBAAsB,MAAM;AAEjD,oBAAc,YAAY;eAExB,UAAU,WAAW,KAAK,YAAY,uBAAuB,MAAM;AAErE,oBAAc,YAAY;WACrB;AAKL,UAAI;AAEJ,aAAO,gBAAgB,QAAQ,gBAAgB,MAAM;AACnD,YAAI,mBAAmB,WAAW,GAAG;AAEnC,qBAAW,cAAc,IAAG;AAC5B,gBAAM,OAAO,SAAS;AACtB,gBAAM,OAAO,SAAS,aAAa,gBAAgB;AACnD,wBAAc;AACd,cAAI,SAAS,UAAU,SAAS,UAAU;AACxC,kBAAM,iBACF,SAAS,aAAa,0BAA0B;AACpD,gBAAI;AACF,oBAAM,SAAS,KAAK,aAAa,EAAC,MAAM,eAAc,CAAC;AACvD,qBAAO,OAAO,SAAS,OAAO;oBACxB;;iBAIH;AACL,uBAAW;;eAER;AACL,gBAAM,cACF,YAAY;AAChB,cAAI,eAAe,MAAM;AACvB,0BAAc;AACd,gBAAI,aAAa,QAAW;AAC1B,uBAAS,cAAe,YAAY,QAAQ;;AAE9C;;AAEF,gBAAM,YACF,KAAA,YAAY,mBAAa,QAAA,OAAA,SAAA,SAAA,GAAE;AAC/B,cAAI,YAAY,MAAM;AACpB,0BAAc;AACd,gBAAI,aAAa,QAAW;AAC1B,uBAAS,cAAe,YAAY,QAAQ;;AAE9C;;AAEF,wBAAc,YAAY;AAC1B,cAAI,aAAa,QAAW;AAC1B,qBAAS,cAAe,YAAY,QAAQ;AAC5C,uBAAW;;;;;;AAMvB;",
  "names": []
}
