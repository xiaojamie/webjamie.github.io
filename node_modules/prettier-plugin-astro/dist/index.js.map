{"version":3,"file":"index.js","sources":["../src/parse.ts","../src/options.ts","../src/nodes.ts","../src/utils.ts","../src/printer.ts","../src/index.ts"],"sourcesContent":["import { parse as parseAstro } from '@astrojs/parser';\n\nconst parse = (text: string) => parseAstro(text);\n\nexport default parse;\n","import { SupportOption } from 'prettier';\n\ndeclare module 'prettier' {\n  interface RequiredOptions extends PluginOptions {}\n}\n\nexport interface PluginOptions {\n  astroSortOrder: SortOrder;\n  astroAllowShorthand: boolean;\n}\n\nexport const options: Record<keyof PluginOptions, SupportOption> = {\n  astroSortOrder: {\n    since: '0.0.1',\n    category: 'Astro',\n    type: 'choice',\n    default: 'markup | styles',\n    description: 'Sort order for markup, scripts, and styles',\n    choices: [\n      {\n        value: 'markup | styles',\n        description: 'markup | styles',\n      },\n      {\n        value: 'styles | markup',\n        description: 'styles | markup',\n      },\n    ],\n  },\n  astroAllowShorthand: {\n    since: '0.0.10',\n    category: 'Astro',\n    type: 'boolean',\n    default: true,\n    description: 'Enable/disable attribute shorthand if attribute name and expression are the same',\n  },\n};\n\nexport const parseSortOrder = (sortOrder: SortOrder): SortOrderPart[] => sortOrder.split(' | ') as SortOrderPart[];\n\nexport type SortOrder = 'markup | styles' | 'styles | markup';\n\nexport type SortOrderPart = 'markup' | 'styles';\n","// TODO: MAYBE WE SHOULD USE TYPES FROM THE PARSER\n\nexport interface Ast {\n  html: anyNode;\n  css: StyleNode[];\n  module: ScriptNode;\n  meta: {\n    features: number;\n  };\n}\n\nexport interface BaseNode {\n  start: number;\n  end: number;\n  type: string;\n  children?: anyNode[];\n  // TODO: ADD BETTER TYPE\n  [prop_name: string]: any;\n}\n\nexport type attributeValue = TextNode[] | AttributeShorthandNode[] | MustacheTagNode[] | true;\n\nexport interface NodeWithChildren {\n  children: anyNode[];\n}\n\nexport interface NodeWithText {\n  data: string;\n  raw?: string;\n}\n\nexport interface FragmentNode extends BaseNode {\n  type: 'Fragment';\n  children: anyNode[];\n}\n\nexport interface TextNode extends BaseNode {\n  type: 'Text';\n  data: string;\n  raw: string;\n}\n\nexport interface CodeFenceNode extends BaseNode {\n  type: 'CodeFence';\n  metadata: string;\n  data: string;\n  raw: string;\n}\n\nexport interface CodeSpanNode extends BaseNode {\n  type: 'CodeSpan';\n  metadata: string;\n  data: string;\n  raw: string;\n}\n\nexport interface SpreadNode extends BaseNode {\n  type: 'Spread';\n  expression: ExpressionNode;\n}\n\nexport interface ExpressionNode {\n  type: 'Expression';\n  start: number;\n  end: number;\n  codeChunks: string[];\n  children: anyNode[];\n}\n\nexport interface ScriptNode extends BaseNode {\n  type: 'Script';\n  context: 'runtime' | 'setup';\n  content: string;\n}\n\nexport interface StyleNode extends BaseNode {\n  type: 'Style';\n  // TODO: ADD BETTER TYPE\n  attributes: any[];\n  content: {\n    start: number;\n    end: number;\n    styles: string;\n  };\n}\n\nexport interface AttributeNode extends BaseNode {\n  type: 'Attribute';\n  name: string;\n  value: attributeValue;\n}\n\nexport interface AttributeShorthandNode extends BaseNode {\n  type: 'AttributeShorthand';\n  expression: IdentifierNode;\n}\n\nexport interface IdentifierNode extends BaseNode {\n  type: 'Identifier';\n  name: string;\n}\n\nexport interface MustacheTagNode extends BaseNode {\n  type: 'MustacheTag';\n  expression: ExpressionNode;\n}\n\nexport interface SlotNode extends BaseNode {\n  type: 'Slot';\n  name: string;\n  attributes: AttributeNode[];\n}\n\nexport interface CommentNode extends BaseNode {\n  type: 'Comment';\n  data: string;\n  name?: string;\n  leading?: boolean;\n  trailing?: boolean;\n  printed?: boolean;\n  nodeDescription?: string;\n}\n\nexport interface ElementNode extends BaseNode {\n  type: 'Element';\n  name: string;\n  attributes: AttributeNode[];\n}\n\nexport interface InlineComponentNode extends BaseNode {\n  type: 'InlineComponent';\n  name: string;\n  attributes: AttributeNode[];\n}\n\nexport interface BlockElementNode extends ElementNode {\n  name: typeof blockElementsT[number];\n}\n\nexport interface InlineElementNode extends ElementNode {\n  name: typeof inlineElementsT[number];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Elements\nconst blockElementsT = [\n  'address',\n  'article',\n  'aside',\n  'blockquote',\n  'details',\n  'dialog',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'li',\n  'main',\n  'nav',\n  'ol',\n  'p',\n  'pre',\n  'section',\n  'table',\n  'ul',\n] as const;\n// https://github.com/microsoft/TypeScript/issues/31018\nexport const blockElements: string[] = [...blockElementsT];\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\nconst inlineElementsT = [\n  'a',\n  'abbr',\n  'acronym',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'br',\n  'button',\n  'canvas',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'embed',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'object',\n  'output',\n  'picture',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'select',\n  'slot',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'svg',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'tt',\n  'var',\n  'video',\n  'wbr',\n] as const;\n// https://github.com/microsoft/TypeScript/issues/31018\nexport const inlineElements: string[] = [...inlineElementsT];\n\n// @see http://xahlee.info/js/html5_non-closing_tag.html\nexport const selfClosingTags = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\nexport type anyNode =\n  | AttributeNode\n  | AttributeShorthandNode\n  | BlockElementNode\n  | CodeFenceNode\n  | CodeSpanNode\n  | CommentNode\n  | ElementNode\n  | ExpressionNode\n  | FragmentNode\n  | IdentifierNode\n  | InlineComponentNode\n  | InlineElementNode\n  | MustacheTagNode\n  | MustacheTagNode\n  | ScriptNode\n  | SlotNode\n  | SpreadNode\n  | StyleNode\n  | TextNode;\n","import { AstPath as AstP, doc, Doc, ParserOptions as ParserOpts, util } from 'prettier';\n\nimport {\n  anyNode,\n  Ast,\n  AttributeNode,\n  AttributeShorthandNode,\n  attributeValue,\n  BlockElementNode,\n  blockElements,\n  InlineElementNode,\n  MustacheTagNode,\n  NodeWithChildren,\n  NodeWithText,\n  TextNode,\n} from './nodes';\n\ntype ParserOptions = ParserOpts<anyNode>;\ntype AstPath = AstP<anyNode>;\n\n/**\n * HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)\n */\nexport const formattableAttributes: string[] = [\n  // None at the moment\n  // Prettier HTML does not format attributes at all\n  // and to be consistent we leave this array empty for now\n];\n\nconst rootNodeKeys = new Set(['html', 'css', 'module']);\n\nexport const isASTNode = (node: anyNode | Ast): node is Ast => typeof node === 'object' && Object.keys(node).filter((key) => rootNodeKeys.has(key)).length === rootNodeKeys.size;\n\nexport const isEmptyTextNode = (node: anyNode): boolean => {\n  return !!node && node.type === 'Text' && getUnencodedText(node).trim() === '';\n};\n\nexport const isPreTagContent = (path: AstPath): boolean => {\n  if (!path || !path.stack || !Array.isArray(path.stack)) return false;\n  return path.stack.some(\n    (node: anyNode) => (node.type === 'Element' && node.name.toLowerCase() === 'pre') || (node.type === 'Attribute' && !formattableAttributes.includes(node.name))\n  );\n};\n\nexport function isLoneMustacheTag(node: attributeValue): node is [MustacheTagNode] {\n  return node !== true && node.length === 1 && node[0].type === 'MustacheTag';\n}\n\nfunction isAttributeShorthand(node: attributeValue): node is [AttributeShorthandNode] {\n  return node !== true && node.length === 1 && node[0].type === 'AttributeShorthand';\n}\n\n/**\n * True if node is of type `{a}` or `a={a}`\n */\nexport function isOrCanBeConvertedToShorthand(node: AttributeNode, opts: ParserOptions): boolean {\n  if (!opts.astroAllowShorthand) return false;\n  if (isAttributeShorthand(node.value)) {\n    return true;\n  }\n\n  if (isLoneMustacheTag(node.value)) {\n    const expression = node.value[0].expression;\n    return expression.codeChunks[0].trim() === node.name;\n    // return (expression.type === 'Identifier' && expression.name === node.name) || (expression.type === 'Expression' && expression.codeChunks[0] === node.name);\n  }\n\n  return false;\n}\n\n/**\n *  True if node is of type `{a}` and astroAllowShorthand is false\n */\nexport function isShorthandAndMustBeConvertedToBinaryExpression(node: AttributeNode, opts: ParserOptions): boolean {\n  if (opts.astroAllowShorthand) return false;\n  if (isAttributeShorthand(node.value)) {\n    return true;\n  }\n  return false;\n}\n\nexport function flatten<T>(arrays: T[][]): T[] {\n  return ([] as T[]).concat.apply([], arrays);\n}\n\nexport function getText(node: anyNode, opts: ParserOptions): string {\n  return opts.originalText.slice(opts.locStart(node), opts.locEnd(node));\n  // const leadingComments = node.leadingComments;\n\n  // return options.originalText.slice(\n  //   options.locStart(\n  //     // if there are comments before the node they are not included\n  //     // in the `start` of the node itself\n  //     (leadingComments && leadingComments[0]) || node\n  //   ),\n  //   options.locEnd(node)\n  // );\n}\n\nexport function getUnencodedText(node: NodeWithText): string {\n  // `raw` will contain HTML entities in unencoded form\n  return node.raw || node.data;\n}\n\nexport function replaceEndOfLineWith(text: string, replacement: doc.builders.DocCommand): Doc[] {\n  const parts = [];\n  for (const part of text.split('\\n')) {\n    if (parts.length > 0) {\n      parts.push(replacement);\n    }\n    if (part.endsWith('\\r')) {\n      parts.push(part.slice(0, -1));\n    } else {\n      parts.push(part);\n    }\n  }\n  return parts;\n}\n\nexport function printRaw(node: anyNode, originalText: string, stripLeadingAndTrailingNewline: boolean = false): string {\n  if (!isNodeWithChildren(node)) {\n    return '';\n  }\n\n  if (node.children.length === 0) {\n    return '';\n  }\n\n  const firstChild = node.children[0];\n  const lastChild = node.children[node.children.length - 1];\n\n  let raw = originalText.substring(firstChild.start, lastChild.end);\n\n  if (!stripLeadingAndTrailingNewline) {\n    return raw;\n  }\n\n  if (startsWithLinebreak(raw)) {\n    raw = raw.substring(raw.indexOf('\\n') + 1);\n  }\n  if (endsWithLinebreak(raw)) {\n    raw = raw.substring(0, raw.lastIndexOf('\\n'));\n    if (raw.charAt(raw.length - 1) === '\\r') {\n      raw = raw.substring(0, raw.length - 1);\n    }\n  }\n\n  return raw;\n}\n\nexport function isNodeWithChildren(node: anyNode): node is anyNode & NodeWithChildren {\n  return node && Array.isArray(node.children);\n}\n\nexport function isInlineElement(path: AstPath, opts: ParserOptions, node: anyNode): node is InlineElementNode {\n  return node && node.type === 'Element' && !isBlockElement(node, opts) && !isPreTagContent(path);\n}\n\nexport function isBlockElement(node: anyNode, opts: ParserOptions): node is BlockElementNode {\n  return node && node.type === 'Element' && opts.htmlWhitespaceSensitivity !== 'strict' && (opts.htmlWhitespaceSensitivity === 'ignore' || blockElements.includes(node.name));\n}\n\nexport function isTextNodeStartingWithLinebreak(node: TextNode, nrLines: number = 1): node is TextNode {\n  return startsWithLinebreak(getUnencodedText(node), nrLines);\n  // return node.type === 'Text' && startsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function startsWithLinebreak(text: string, nrLines: number = 1): boolean {\n  return new RegExp(`^([\\\\t\\\\f\\\\r ]*\\\\n){${nrLines}}`).test(text);\n}\n\nexport function isTextNodeEndingWithLinebreak(node: TextNode, nrLines: number = 1) {\n  return node.type === 'Text' && endsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function endsWithLinebreak(text: string, nrLines: number = 1): boolean {\n  return new RegExp(`(\\\\n[\\\\t\\\\f\\\\r ]*){${nrLines}}$`).test(text);\n}\n\nexport function isTextNodeStartingWithWhitespace(node: anyNode): node is TextNode {\n  return node.type === 'Text' && /^\\s/.test(getUnencodedText(node));\n}\n\nexport function isTextNodeEndingWithWhitespace(node: anyNode): node is TextNode {\n  return node.type === 'Text' && /\\s$/.test(getUnencodedText(node));\n}\n\nexport function forceIntoExpression(statement: string): string {\n  // note the trailing newline: if the statement ends in a // comment,\n  // we can't add the closing bracket right afterwards\n  return `(${statement}\\n)`;\n}\n\n/**\n * Check if given node's starg tag should hug its first child. This is the case for inline elements when there's\n * no whitespace between the `>` and the first child.\n */\nexport function shouldHugStart(node: anyNode, opts: ParserOptions): boolean {\n  if (isBlockElement(node, opts)) {\n    return false;\n  }\n\n  if (!isNodeWithChildren(node)) {\n    return false;\n  }\n\n  const children = node.children;\n  if (children.length === 0) {\n    return true;\n  }\n\n  const firstChild = children[0];\n  return !isTextNodeStartingWithWhitespace(firstChild);\n}\n\n/**\n * Check if given node's end tag should hug its last child. This is the case for inline elements when there's\n * no whitespace between the last child and the `</`.\n */\nexport function shouldHugEnd(node: anyNode, opts: ParserOptions): boolean {\n  if (isBlockElement(node, opts)) {\n    return false;\n  }\n\n  if (!isNodeWithChildren(node)) {\n    return false;\n  }\n\n  const children = node.children;\n  if (children.length === 0) {\n    return true;\n  }\n\n  const lastChild = children[children.length - 1];\n  return !isTextNodeEndingWithWhitespace(lastChild);\n}\n\n/**\n * Returns true if the softline between `</tagName` and `>` can be omitted.\n */\nexport function canOmitSoftlineBeforeClosingTag(path: AstPath, opts: ParserOptions): boolean {\n  return isLastChildWithinParentBlockElement(path, opts);\n  // return !hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options);\n  // return !options.svelteBracketNewLine && (!hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options));\n}\n\n/**\n * Return true if given node does not hug the next node, meaning there's whitespace\n * or the end of the doc afterwards.\n */\nfunction hugsStartOfNextNode(node: anyNode, opts: ParserOptions): boolean {\n  if (node.end === opts.originalText.length) {\n    // end of document\n    return false;\n  }\n\n  return !opts.originalText.substring(node.end).match(/^\\s/);\n}\n\nfunction getChildren(node: anyNode): anyNode[] {\n  return isNodeWithChildren(node) ? node.children : [];\n}\n\nfunction isLastChildWithinParentBlockElement(path: AstPath, opts: ParserOptions): boolean {\n  const parent = path.getParentNode();\n  if (!parent || !isBlockElement(parent, opts)) {\n    return false;\n  }\n\n  const children = getChildren(parent);\n  const lastChild = children[children.length - 1];\n  return lastChild === path.getNode();\n}\n\nexport function trimTextNodeLeft(node: TextNode): void {\n  node.raw = node.raw && node.raw.trimLeft();\n  node.data = node.data && node.data.trimLeft();\n}\n\nexport function trimTextNodeRight(node: TextNode): void {\n  node.raw = node.raw && node.raw.trimRight();\n  node.data = node.data && node.data.trimRight();\n}\n\nexport function findLastIndex<T>(isMatch: (item: T, idx: number) => boolean, items: T[]) {\n  for (let i = items.length - 1; i >= 0; i--) {\n    if (isMatch(items[i], i)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Remove all leading whitespace up until the first non-empty text node,\n * and all trailing whitepsace from the last non-empty text node onwards.\n */\nexport function trimChildren(children: anyNode[]) {\n  // export function trimChildren(children: anyNode[], path: AstPath<anyNode>) {\n  let firstNonEmptyNode = children.findIndex((n) => !isEmptyTextNode(n));\n  // let firstNonEmptyNode = children.findIndex((n) => !isEmptyTextNode(n) && !doesEmbedStartAfterNode(n, path));\n  firstNonEmptyNode = firstNonEmptyNode === -1 ? children.length - 1 : firstNonEmptyNode;\n\n  let lastNonEmptyNode = findLastIndex((n, idx) => {\n    // Last node is ok to end at the start of an embedded region,\n    // if it's not a comment (which should stick to the region)\n    return !isEmptyTextNode(n);\n    // return !isEmptyTextNode(n) && ((idx === children.length - 1 && n.type !== 'Comment') || !doesEmbedStartAfterNode(n, path));\n  }, children);\n  lastNonEmptyNode = lastNonEmptyNode === -1 ? 0 : lastNonEmptyNode;\n\n  for (let i = 0; i <= firstNonEmptyNode; i++) {\n    const n = children[i];\n    if (isTextNode(n)) {\n      trimTextNodeLeft(n);\n    }\n  }\n\n  for (let i = children.length - 1; i >= lastNonEmptyNode; i--) {\n    const n = children[i];\n    if (isTextNode(n)) {\n      trimTextNodeRight(n);\n    }\n  }\n}\n\n/**\n * Returns siblings, that is, the children of the parent.\n */\nexport function getSiblings(path: AstPath): anyNode[] {\n  let parent = path.getParentNode();\n  if (!parent) return [];\n\n  if (isASTNode(parent)) {\n    parent = parent.html;\n  }\n\n  return getChildren(parent);\n}\n\n/**\n * Did there use to be any embedded object (that has been snipped out of the AST to be moved)\n * at the specified position?\n */\n// function doesEmbedStartAfterNode(node: anyNode, path: AstPath<anyNode>, siblings = getSiblings(path)): boolean {\n//   // If node is not at the top level of html, an embed cannot start after it,\n//   // because embeds are only at the top level\n//   if (!isNodeTopLevelHTML(node, path)) {\n//     return false;\n//   }\n\n//   const position = node.end;\n//   const root = path.stack[0];\n\n//   const embeds = [root.module, root.html, root.css];\n\n//   const nextNode = siblings[siblings.indexOf(node) + 1];\n//   return embeds.find((n) => n && n.start >= position && (!nextNode || n.end <= nextNode.start));\n// }\n\n// function isNodeTopLevelHTML(node: anyNode, path: AstPath<anyNode>) {\n//   const root = path.stack[0];\n//   return !!root.html && !!root.html.children && root.html.children.includes(node);\n// }\n\n/**\n * Check if doc is a hardline.\n * We can't just rely on a simple equality check because the doc could be created with another\n * runtime version of prettier than what we import, making a reference check fail.\n */\n\nfunction isHardline(docToCheck: Doc): boolean {\n  return docToCheck === doc.builders.hardline || deepEqual(docToCheck, doc.builders.hardline);\n}\n\n/**\n * Simple deep equal function which suits our needs. Only works properly on POJOs without cyclic deps.\n */\nfunction deepEqual(x: any, y: any): boolean {\n  if (x === y) {\n    return true;\n  } else if (typeof x == 'object' && x != null && typeof y == 'object' && y != null) {\n    if (Object.keys(x).length != Object.keys(y).length) return false;\n\n    for (var prop in x) {\n      if (Object.prototype.hasOwnProperty.call(y, prop)) {\n        if (!deepEqual(x[prop], y[prop])) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function isLine(docToCheck: Doc): boolean {\n  return (\n    isHardline(docToCheck) ||\n    (typeof docToCheck === 'object' && isDocCommand(docToCheck) && docToCheck.type === 'line') ||\n    (typeof docToCheck === 'object' && isDocCommand(docToCheck) && docToCheck.type === 'concat' && docToCheck.parts.every(isLine))\n  );\n}\n\n/**\n * Check if the doc is empty, i.e. consists of nothing more than empty strings (possibly nested).\n */\nexport function isEmptyDoc(doc: Doc): boolean {\n  if (typeof doc === 'string') {\n    return doc.length === 0;\n  }\n\n  // if (doc.type === 'line') {\n  //   return !doc.keepIfLonely;\n  // }\n\n  // Since Prettier 2.3.0, concats are represented as flat arrays\n  if (Array.isArray(doc)) {\n    return doc.length === 0;\n  }\n\n  // const { contents } = doc;\n\n  // if (contents) {\n  //   return isEmptyDoc(contents);\n  // }\n\n  // const { parts } = doc;\n\n  // if (parts) {\n  //   return isEmptyGroup(parts);\n  // }\n\n  return false;\n}\n\n// function isEmptyGroup(group: any) {\n//   return !group.find((doc: any) => !isEmptyDoc(doc));\n// }\n\n/**\n * Trims both leading and trailing nodes matching `isWhitespace` independent of nesting level\n * (though all trimmed adjacent nodes need to be a the same level). Modifies the `docs` array.\n */\nexport function trim(docs: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] {\n  trimLeft(docs, isWhitespace);\n  trimRight(docs, isWhitespace);\n\n  return docs;\n}\n\n/**\n * Trims the leading nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs before the first whitespace, they are removed, too.\n */\nfunction trimLeft(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n  let firstNonWhitespace = group.findIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc));\n\n  if (firstNonWhitespace < 0 && group.length) {\n    firstNonWhitespace = group.length;\n  }\n\n  if (firstNonWhitespace > 0) {\n    const removed = group.splice(0, firstNonWhitespace);\n    if (removed.every(isEmptyDoc)) {\n      return trimLeft(group, isWhitespace);\n    }\n  } else {\n    const parts = getParts(group[0]);\n\n    if (parts) {\n      return trimLeft(parts, isWhitespace);\n    }\n  }\n}\n\n/**\n * Trims the trailing nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs after the last whitespace, they are removed, too.\n */\nfunction trimRight(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n  let lastNonWhitespace = group.length ? findLastIndex((doc: any) => !isEmptyDoc(doc) && !isWhitespace(doc), group) : 0;\n\n  if (lastNonWhitespace < group.length - 1) {\n    const removed = group.splice(lastNonWhitespace + 1);\n    if (removed.every(isEmptyDoc)) {\n      return trimRight(group, isWhitespace);\n    }\n  } else {\n    const parts = getParts(group[group.length - 1]);\n\n    if (parts) {\n      return trimRight(parts, isWhitespace);\n    }\n  }\n}\n\nfunction getParts(doc: Doc): Doc[] | undefined {\n  if (typeof doc === 'object') {\n    // Since Prettier 2.3.0, concats are represented as flat arrays\n    if (Array.isArray(doc)) {\n      return doc;\n    }\n    if (doc.type === 'fill' || doc.type === 'concat') {\n      return doc.parts;\n    }\n    if (doc.type === 'group') {\n      return getParts(doc.contents);\n    }\n  }\n}\n\nexport const isObjEmpty = (obj: object): boolean => {\n  for (let i in obj) return false;\n  return true;\n};\n\n/** Shallowly attach comments to children */\nexport function attachCommentsHTML(node: anyNode): void {\n  if (!isNodeWithChildren(node) || !node.children.some(({ type }) => type === 'Comment')) return;\n\n  const nodesToRemove = [];\n\n  // note: the .length - 1 is because we don’t need to read the last node\n  for (let n = 0; n < node.children.length - 1; n++) {\n    if (!node.children[n]) continue;\n\n    // attach comment to the next non-whitespace node\n    if (node.children[n].type === 'Comment') {\n      let next = n + 1;\n      while (isEmptyTextNode(node.children[next])) {\n        nodesToRemove.push(next); // if arbitrary whitespace between comment and node, remove\n        next++; // skip to the next non-whitespace node\n      }\n      const commentNode = node.children[next];\n      if (commentNode) {\n        const comment = node.children[n];\n        util.addLeadingComment(commentNode, comment);\n      }\n    }\n  }\n\n  // remove arbitrary whitespace nodes\n  nodesToRemove.reverse(); // start at back so we aren’t changing indices\n  nodesToRemove.forEach((index) => {\n    node.children.splice(index, 1);\n  });\n}\n\n/** dedent string & return tabSize (the last part is what we need) */\nexport function dedent(input: string): { tabSize: number; char: string; result: string } {\n  let minTabSize = Infinity;\n  let result = input;\n  // 1. normalize\n  result = result.replace(/\\r\\n/g, '\\n');\n\n  // 2. count tabSize\n  let char = '';\n  for (const line of result.split('\\n')) {\n    if (!line) continue;\n    // if any line begins with a non-whitespace char, minTabSize is 0\n    if (line[0] && /^[^\\s]/.test(line[0])) {\n      minTabSize = 0;\n      break;\n    }\n    const match = line.match(/^(\\s+)\\S+/); // \\S ensures we don’t count lines of pure whitespace\n    if (match) {\n      if (match[1] && !char) char = match[1][0];\n      if (match[1].length < minTabSize) minTabSize = match[1].length;\n    }\n  }\n\n  // 3. reformat string\n  if (minTabSize > 0 && Number.isFinite(minTabSize)) {\n    result = result.replace(new RegExp(`^${new Array(minTabSize + 1).join(char)}`, 'gm'), '');\n  }\n\n  return {\n    tabSize: minTabSize === Infinity ? 0 : minTabSize,\n    char,\n    result,\n  };\n}\n\n/** re-indent string by chars */\nexport function indent(input: string, char: string = ' '): string {\n  return input.replace(/^(.)/gm, `${char}$1`);\n}\n\n/** scan code for Markdown name(s) */\nexport function getMarkdownName(script: string): Set<string> {\n  // default import: could be named anything\n  let defaultMatch;\n  while ((defaultMatch = /import\\s+([^\\s]+)\\s+from\\s+['|\"|`]astro\\/components\\/Markdown\\.astro/g.exec(script))) {\n    if (defaultMatch[1]) return new Set([defaultMatch[1].trim()]);\n  }\n\n  // named component: must have \"Markdown\" in specifier, but can be renamed via \"as\"\n  let namedMatch;\n  while ((namedMatch = /import\\s+\\{\\s*([^}]+)\\}\\s+from\\s+['|\"|`]astro\\/components/g.exec(script))) {\n    if (namedMatch[1] && !namedMatch[1].includes('Markdown')) continue;\n    // if \"Markdown\" was imported, find out whether or not it was renamed\n    const rawImports = namedMatch[1].trim().replace(/^\\{/, '').replace(/\\}$/, '').trim();\n    let importName = 'Markdown';\n    for (const spec of rawImports.split(',')) {\n      const [original, renamed] = spec.split(' as ').map((s) => s.trim());\n      if (original !== 'Markdown') continue;\n      importName = renamed || original;\n      break;\n    }\n    return new Set([importName]);\n  }\n  return new Set(['Markdown']);\n}\n\nexport function isTextNode(node: anyNode): node is TextNode {\n  return node.type === 'Text';\n}\n\nexport function isMustacheNode(node: anyNode): node is MustacheTagNode {\n  return node.type === 'MustacheTag';\n}\n\nexport function isDocCommand(doc: Doc): doc is doc.builders.DocCommand {\n  if (typeof doc === 'string') return false;\n  if (Array.isArray(doc)) return false;\n  return true;\n}\n\nexport function isInsideQuotedAttribute(path: AstPath): boolean {\n  const stack = path.stack as anyNode[];\n  return stack.some((node) => node.type === 'Attribute' && !isLoneMustacheTag(node.value));\n}\n","import { AstPath as AstP, Doc, ParserOptions as ParserOpts, Printer } from 'prettier';\nimport _doc from 'prettier/doc';\nconst {\n  builders: { breakParent, dedent, fill, group, hardline, indent, join, line, literalline, softline },\n  utils: { removeLines, stripTrailingHardline },\n} = _doc;\nimport { SassFormatter, SassFormatterConfig } from 'sass-formatter';\n\nimport { parseSortOrder } from './options';\nimport { Ast, anyNode, AttributeNode, CommentNode, NodeWithText, selfClosingTags, TextNode } from './nodes';\n\ntype ParserOptions = ParserOpts<anyNode>;\ntype AstPath = AstP<anyNode>;\n\nimport {\n  attachCommentsHTML,\n  canOmitSoftlineBeforeClosingTag,\n  dedent as manualDedent,\n  endsWithLinebreak,\n  forceIntoExpression,\n  formattableAttributes,\n  getMarkdownName,\n  getText,\n  getUnencodedText,\n  isASTNode,\n  isDocCommand,\n  isEmptyDoc,\n  isEmptyTextNode,\n  isInlineElement,\n  isInsideQuotedAttribute,\n  isLine,\n  isLoneMustacheTag,\n  isNodeWithChildren,\n  isOrCanBeConvertedToShorthand,\n  isPreTagContent,\n  isShorthandAndMustBeConvertedToBinaryExpression,\n  isTextNode,\n  isTextNodeEndingWithWhitespace,\n  isTextNodeStartingWithLinebreak,\n  isTextNodeStartingWithWhitespace,\n  printRaw,\n  replaceEndOfLineWith,\n  shouldHugEnd,\n  shouldHugStart,\n  startsWithLinebreak,\n  trim,\n  trimChildren,\n  trimTextNodeLeft,\n  trimTextNodeRight,\n} from './utils';\n\nfunction printTopLevelParts(node: Ast, path: AstPath, opts: ParserOptions, print: printFn): Doc {\n  let docs = [];\n\n  const normalize = (doc: Doc) => [stripTrailingHardline(doc), hardline];\n\n  // frontmatter always comes first\n  if (node.module) {\n    const subDoc = normalize(path.call(print, 'module'));\n    docs.push(subDoc);\n  }\n\n  // markup and styles follow, whichever the user prefers (default: markup, styles)\n  for (const section of parseSortOrder(opts.astroSortOrder)) {\n    switch (section) {\n      case 'markup': {\n        const subDoc = path.call(print, 'html');\n        if (!isEmptyDoc(subDoc)) docs.push(normalize(subDoc));\n        break;\n      }\n      case 'styles': {\n        const subDoc = path.call(print, 'css');\n        if (!isEmptyDoc(subDoc)) docs.push(normalize(subDoc));\n        break;\n      }\n    }\n  }\n\n  return join(softline, docs);\n}\n\nfunction printAttributeNodeValue(path: AstPath, print: printFn, quotes: boolean, node: AttributeNode): Doc[] | _doc.builders.Indent {\n  const valueDocs = path.map((childPath) => childPath.call(print), 'value');\n\n  if (!quotes || !formattableAttributes.includes(node.name)) {\n    return valueDocs;\n  } else {\n    return indent(group(trim(valueDocs, isLine)));\n  }\n}\n\n// TODO: USE ASTPATH GENERIC\nfunction printJS(path: AstP, print: printFn, name: string, { forceSingleQuote, forceSingleLine }: { forceSingleQuote: boolean; forceSingleLine: boolean }) {\n  path.getValue()[name].isJS = true;\n  path.getValue()[name].forceSingleQuote = forceSingleQuote;\n  path.getValue()[name].forceSingleLine = forceSingleLine;\n  return path.call(print, name);\n}\n\n// TODO: MAYBE USE THIS TO HANDLE COMMENTS\nfunction printComment(commentPath: AstPath, options: ParserOptions): Doc {\n  // note(drew): this isn’t doing anything currently, but Prettier requires it anyway\n  // @ts-ignore\n  return commentPath;\n}\n\nexport type printFn = (path: AstPath) => Doc;\n\nfunction print(path: AstPath, opts: ParserOptions, print: printFn): Doc {\n  const node = path.getValue();\n  const isMarkdownSubDoc = opts.parentParser === 'markdown'; // is this a code block within .md?\n\n  // 1. handle special node types\n  if (!node) {\n    return '';\n  }\n\n  if (typeof node === 'string') {\n    return node;\n  }\n\n  if (Array.isArray(node)) {\n    return path.map((childPath) => childPath.call(print));\n  }\n\n  if (isASTNode(node)) {\n    return printTopLevelParts(node, path, opts, print);\n  }\n\n  // 2. attach comments shallowly to children, if any (https://prettier.io/docs/en/plugins.html#manually-attaching-a-comment)\n  if (!isPreTagContent(path) && !isMarkdownSubDoc && node.type === 'Fragment') {\n    attachCommentsHTML(node);\n  }\n\n  // 3. handle printing\n  switch (node.type) {\n    case 'Fragment': {\n      const text = getText(node, opts);\n      if (text.length === 0) {\n        return '';\n      }\n\n      if (!isNodeWithChildren(node) || node.children.every(isEmptyTextNode)) return '';\n\n      if (!isPreTagContent(path)) {\n        trimChildren(node.children);\n        const output = trim(\n          [path.map(print, 'children')],\n          (n) =>\n            isLine(n) ||\n            (typeof n === 'string' && n.trim() === '') ||\n            // Because printChildren may append this at the end and\n            // may hide other lines before it\n            n === breakParent\n        );\n        if (output.every((doc) => isEmptyDoc(doc))) {\n          return '';\n        }\n        return group([...output, hardline]);\n      } else {\n        return group(path.map(print, 'children'));\n      }\n    }\n    case 'Text': {\n      const rawText = getUnencodedText(node);\n\n      if (isPreTagContent(path)) {\n        if (path.getParentNode()?.type === 'Attribute') {\n          // Direct child of attribute value -> add literallines at end of lines\n          // so that other things don't break in unexpected places\n          return replaceEndOfLineWith(rawText, literalline);\n        }\n        return rawText;\n      }\n\n      if (isEmptyTextNode(node)) {\n        const hasWhiteSpace = rawText.trim().length < getUnencodedText(node).length;\n        const hasOneOrMoreNewlines = /\\n/.test(getUnencodedText(node));\n        const hasTwoOrMoreNewlines = /\\n\\r?\\s*\\n\\r?/.test(getUnencodedText(node));\n        if (hasTwoOrMoreNewlines) {\n          return [hardline, hardline];\n        }\n        if (hasOneOrMoreNewlines) {\n          return hardline;\n        }\n        if (hasWhiteSpace) {\n          return line;\n        }\n        return '';\n      }\n\n      /**\n       * For non-empty text nodes each sequence of non-whitespace characters (effectively,\n       * each \"word\") is joined by a single `line`, which will be rendered as a single space\n       * until this node's current line is out of room, at which `fill` will break at the\n       * most convenient instance of `line`.\n       */\n      return fill(splitTextToDocs(node));\n    }\n\n    case 'Element':\n    case 'InlineComponent':\n    case 'Slot': {\n      const isEmpty = node.children?.every((child) => isEmptyTextNode(child));\n      const isSelfClosingTag = isEmpty && (node.type !== 'Element' || selfClosingTags.indexOf(node.name) !== -1);\n      const attributes = path.map(print, 'attributes');\n      if (isSelfClosingTag) {\n        return group(['<', node.name, indent(group(attributes)), line, `/>`]);\n        // return group(['<', node.name, indent(group([...attributes, opts.jsxBracketNewLine ? dedent(line) : ''])), ...[opts.jsxBracketNewLine ? '' : ' ', `/>`]]);\n      }\n      try {\n        if (node.name.toLowerCase() === '!doctype') {\n          const attributesWithLowercaseHTML = attributes.map((attribute) => {\n            if (typeof attribute === 'string') return attribute;\n            if (isDocCommand(attribute)) return attribute;\n            attribute = attribute.map((attrValue) => {\n              if (typeof attrValue !== 'string') return attrValue;\n              if (attrValue.toLowerCase() === 'html') {\n                attrValue = attrValue.toLowerCase();\n              }\n              return attrValue;\n            });\n\n            // if (attribute[0].type === 'line' && attribute[1].toLowerCase() === 'html') {\n            //   attribute[1] = attribute[1].toLowerCase();\n            //   return attribute;\n            // }\n            return attribute;\n          });\n\n          return group(['<', node.name.toUpperCase(), ...attributesWithLowercaseHTML, `>`]);\n        }\n      } catch (e) {\n        console.warn(`error ${e} in the doctype printing`);\n      }\n\n      if (node.children) {\n        const children = node.children;\n        const firstChild = children[0];\n        const lastChild = children[children.length - 1];\n\n        // No hugging of content means it's either a block element and/or there's whitespace at the start/end\n        let noHugSeparatorStart: _doc.builders.Concat | _doc.builders.Line | _doc.builders.Softline | string = softline;\n        let noHugSeparatorEnd: _doc.builders.Concat | _doc.builders.Line | _doc.builders.Softline | string = softline;\n        let hugStart = shouldHugStart(node, opts);\n        let hugEnd = shouldHugEnd(node, opts);\n\n        let body;\n\n        if (isEmpty) {\n          body =\n            isInlineElement(path, opts, node) && node.children.length && isTextNodeStartingWithWhitespace(node.children[0]) && !isPreTagContent(path)\n              ? () => line\n              : // () => (opts.jsxBracketNewLine ? '' : softline);\n                () => softline;\n        } else if (isPreTagContent(path)) {\n          body = () => printRaw(node, opts.originalText);\n        } else if (isInlineElement(path, opts, node) && !isPreTagContent(path)) {\n          body = () => path.map(print, 'children');\n        } else {\n          body = () => path.map(print, 'children');\n        }\n\n        const openingTag = ['<', node.name, indent(group([...attributes, hugStart ? '' : !isPreTagContent(path) && !opts.bracketSameLine ? dedent(softline) : '']))];\n        // const openingTag = ['<', node.name, indent(group([...attributes, hugStart ? '' : opts.jsxBracketNewLine && !isPreTagContent(path) ? dedent(softline) : '']))];\n\n        if (hugStart && hugEnd) {\n          const huggedContent = [softline, group(['>', body(), `</${node.name}`])];\n\n          const omitSoftlineBeforeClosingTag = isEmpty || canOmitSoftlineBeforeClosingTag(path, opts);\n          // const omitSoftlineBeforeClosingTag = (isEmpty && opts.jsxBracketNewLine) || canOmitSoftlineBeforeClosingTag(node, path, opts);\n          return group([...openingTag, isEmpty ? group(huggedContent) : group(indent(huggedContent)), omitSoftlineBeforeClosingTag ? '' : softline, '>']);\n        }\n\n        if (isPreTagContent(path)) {\n          noHugSeparatorStart = '';\n          noHugSeparatorEnd = '';\n        } else {\n          let didSetEndSeparator = false;\n\n          if (!hugStart && firstChild && isTextNode(firstChild)) {\n            if (isTextNodeStartingWithLinebreak(firstChild) && firstChild !== lastChild && (!isInlineElement(path, opts, node) || isTextNodeEndingWithWhitespace(lastChild))) {\n              noHugSeparatorStart = hardline;\n              noHugSeparatorEnd = hardline;\n              didSetEndSeparator = true;\n            } else if (isInlineElement(path, opts, node)) {\n              noHugSeparatorStart = line;\n            }\n            trimTextNodeLeft(firstChild);\n          }\n          if (!hugEnd && lastChild && isTextNode(lastChild)) {\n            if (isInlineElement(path, opts, node) && !didSetEndSeparator) {\n              noHugSeparatorEnd = line;\n            }\n            trimTextNodeRight(lastChild);\n          }\n        }\n\n        if (hugStart) {\n          return group([...openingTag, indent([softline, group(['>', body()])]), noHugSeparatorEnd, `</${node.name}>`]);\n        }\n\n        if (hugEnd) {\n          return group([...openingTag, '>', indent([noHugSeparatorStart, group([body(), `</${node.name}`])]), canOmitSoftlineBeforeClosingTag(path, opts) ? '' : softline, '>']);\n        }\n\n        if (isEmpty) {\n          return group([...openingTag, '>', body(), `</${node.name}>`]);\n        }\n\n        return group([...openingTag, '>', indent([noHugSeparatorStart, body()]), noHugSeparatorEnd, `</${node.name}>`]);\n      }\n    }\n    case 'AttributeShorthand': {\n      return node.expression.name;\n    }\n    case 'Attribute': {\n      if (isOrCanBeConvertedToShorthand(node, opts)) {\n        return [line, '{', node.name, '}'];\n      } else if (isShorthandAndMustBeConvertedToBinaryExpression(node, opts)) {\n        const attrNodeValue = printAttributeNodeValue(path, print, true, node);\n        return [line, node.name, '=', '{', attrNodeValue, '}'];\n      } else if (node.value === true) {\n        return [line, node.name];\n      }\n\n      const quotes = !isLoneMustacheTag(node.value);\n      const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);\n      if (quotes) {\n        return [line, node.name, '=', '\"', attrNodeValue, '\"'];\n      } else {\n        return [line, node.name, '=', attrNodeValue];\n      }\n    }\n    case 'Expression':\n      // missing test ?\n      return [];\n    case 'MustacheTag':\n      return [\n        '{',\n        printJS(path, print, 'expression', {\n          forceSingleLine: isInsideQuotedAttribute(path),\n          forceSingleQuote: opts.jsxSingleQuote,\n        }),\n        '}',\n      ];\n    case 'Spread':\n      return [\n        line,\n        '{...',\n        printJS(path, print, 'expression', {\n          forceSingleQuote: true,\n          forceSingleLine: false,\n        }),\n        '}',\n      ];\n    case 'Comment':\n      return ['<!--', getUnencodedText(node), '-->'];\n    case 'CodeSpan':\n      return getUnencodedText(node);\n    case 'CodeFence': {\n      console.debug(node);\n      // const lang = node.metadata.slice(3);\n      return [node.metadata, hardline, /** somehow call textToDoc(lang),  */ node.data, hardline, '```', hardline];\n\n      // We should use `node.metadata` to select a parser to embed with... something like return [node.metadata, hardline textToDoc(node.getMetadataLanguage()), hardline, `\\`\\`\\``];\n    }\n    default: {\n      throw new Error(`Unhandled node type \"${node.type}\"!`);\n    }\n  }\n}\n\n/**\n * Split the text into words separated by whitespace. Replace the whitespaces by lines,\n * collapsing multiple whitespaces into a single line.\n *\n * If the text starts or ends with multiple newlines, two of those should be kept.\n */\nfunction splitTextToDocs(node: NodeWithText): Doc[] {\n  const text = getUnencodedText(node);\n\n  let textLines = text.split(/[\\t\\n\\f\\r ]+/);\n\n  let docs = join(line, textLines).parts.filter((s) => s !== '');\n\n  if (startsWithLinebreak(text)) {\n    docs[0] = hardline;\n  }\n  if (startsWithLinebreak(text, 2)) {\n    docs = [hardline, ...docs];\n  }\n\n  if (endsWithLinebreak(text)) {\n    docs[docs.length - 1] = hardline;\n  }\n  if (endsWithLinebreak(text, 2)) {\n    docs = [...docs, hardline];\n  }\n\n  return docs;\n}\n\n// TODO: CHANGE 'parsers' TYPE\nfunction expressionParser(text: string, parsers: any, opts: ParserOptions) {\n  const ast = parsers.babel(text, parsers, opts);\n\n  return { ...ast, program: ast.program.body[0].expression };\n}\n\nlet markdownComponentName = new Set();\n\nfunction embed(path: AstPath, print: printFn, textToDoc: (text: string, options: object) => Doc, opts: ParserOptions) {\n  // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n  // @ts-ignore\n  if (!opts.__astro) opts.__astro = {};\n\n  const node = path.getValue();\n\n  if (!node) return null;\n\n  // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n  // @ts-ignore\n  if (node.isJS) {\n    try {\n      const embeddedopts = {\n        parser: expressionParser,\n      };\n      // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n      // @ts-ignore\n      if (node.forceSingleQuote) {\n        // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n        // @ts-ignore\n        embeddedopts.singleQuote = true;\n      }\n\n      const docs = textToDoc(forceIntoExpression(getText(node, opts)), embeddedopts);\n      // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n      // @ts-ignore\n      return node.forceSingleLine ? removeLines(docs) : docs;\n    } catch (e) {\n      return getText(node, opts);\n    }\n  }\n\n  if (node.type === 'Script' && node.context === 'setup') {\n    markdownComponentName = getMarkdownName(node.content);\n    return group(['---', hardline, textToDoc(node.content, { ...opts, parser: 'typescript' }), '---', hardline]);\n  }\n\n  // format <script type=\"module\"> content\n  if (isTextNode(node)) {\n    const parent = path.getParentNode();\n\n    if (parent && parent.type === 'Element' && parent.name === 'script') {\n      const formatttedScript = textToDoc(node.data, { ...opts, parser: 'typescript' });\n      return stripTrailingHardline(formatttedScript);\n    }\n  }\n\n  // type style is top level style tag\n  // type element is nested style tag\n  if (node.type === 'Style' || (node.type === 'Element' && node.name === 'style')) {\n    let styleTagContent = '';\n    if (node.type === 'Style') {\n      styleTagContent = node.content.styles;\n    } else if (node.children) {\n      const children = node.children[0] as TextNode;\n      styleTagContent = getUnencodedText(children);\n    }\n\n    const supportedStyleLangValues = ['css', 'scss', 'sass'];\n    let parserLang = 'css';\n\n    if ('attributes' in node) {\n      const langAttribute = node.attributes.filter((x) => x.name === 'lang');\n      if (langAttribute.length) {\n        const styleLang = langAttribute[0].value[0].raw.toLowerCase();\n        if (supportedStyleLangValues.includes(styleLang)) parserLang = styleLang;\n      }\n    }\n\n    switch (parserLang) {\n      case 'css':\n      case 'scss': {\n        // the css parser appends an extra indented hardline, which we want outside of the `indent()`,\n        // so we remove the last element of the array\n        let formattedStyles = textToDoc(styleTagContent, { ...opts, parser: parserLang });\n\n        formattedStyles = stripTrailingHardline(formattedStyles);\n\n        // print\n        const attributes = path.map(print, 'attributes');\n        const openingTag = group(['<style', indent(group(attributes)), softline, '>']);\n        return [openingTag, indent([hardline, formattedStyles]), hardline, '</style>'];\n      }\n      case 'sass': {\n        const lineEnding = opts.endOfLine.toUpperCase() === 'CRLF' ? 'CRLF' : 'LF';\n        const sassOptions: Partial<SassFormatterConfig> = {\n          tabSize: opts.tabWidth,\n          insertSpaces: !opts.useTabs,\n          lineEnding,\n        };\n\n        // dedent the .sass, otherwise SassFormatter gets indentation wrong\n        const { result: raw } = manualDedent(styleTagContent);\n\n        // format\n        let formattedSassIndented = SassFormatter.Format(raw, sassOptions).trim();\n\n        // print\n        const formattedSass = join(hardline, formattedSassIndented.split('\\n'));\n        const attributes = path.map(print, 'attributes');\n        const openingTag = group(['<style', indent(group(attributes)), softline, '>']);\n        return [openingTag, indent(group([hardline, formattedSass])), hardline, '</style>'];\n      }\n    }\n  }\n\n  // MARKDOWN COMPONENT\n  if (node.type === 'InlineComponent' && markdownComponentName.has(node.name)) {\n    let content = printRaw(node, opts.originalText);\n\n    // dedent the content\n    content = content.replace(/\\r\\n/g, '\\n');\n    const contentArr = content.split('\\n').map((s) => s.trimStart());\n    content = contentArr.join('\\n');\n\n    // format\n    let formatttedMarkdown = textToDoc(content, { ...opts, parser: 'markdown' });\n    formatttedMarkdown = stripTrailingHardline(formatttedMarkdown);\n\n    // return formatttedMarkdown;\n    const attributes = path.map(print, 'attributes');\n    const openingTag = group([`<${node.name}`, indent(group(attributes)), softline, '>']);\n    return [openingTag, indent(group([hardline, formatttedMarkdown])), hardline, `</${node.name}>`];\n  }\n\n  return null;\n}\n\nfunction hasPrettierIgnore(path: AstP<CommentNode>) {\n  const node = path.getNode();\n\n  if (!node || !Array.isArray(node.comments)) return false;\n\n  const hasIgnore = node.comments.some(\n    (comment: any) => comment.data.includes('prettier-ignore') && !comment.data.includes('prettier-ignore-start') && !comment.data.includes('prettier-ignore-end')\n  );\n  return hasIgnore;\n}\n\nconst printer: Printer = {\n  print,\n  printComment,\n  embed,\n  hasPrettierIgnore,\n};\n\nexport default printer;\n","import parse from './parse';\nimport printer from './printer';\nimport { options } from './options';\nimport { Parser, Printer, SupportLanguage } from 'prettier';\n\nexport const languages: Partial<SupportLanguage>[] = [\n  {\n    name: 'astro',\n    parsers: ['astro'],\n    extensions: ['.astro'],\n    vscodeLanguageIds: ['astro'],\n  },\n];\n\nexport const parsers: Record<string, Parser> = {\n  astro: {\n    parse,\n    astFormat: 'astro',\n    locStart: (node) => node.start,\n    locEnd: (node) => node.end,\n  },\n};\n\nexport const printers: Record<string, Printer> = {\n  astro: printer,\n};\n\nconst defaultOptions = {\n  tabWidth: 2,\n};\n\nexport { options, defaultOptions };\n"],"names":["parseAstro","doc","util","dedent","_doc","manualDedent","SassFormatter"],"mappings":"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"}