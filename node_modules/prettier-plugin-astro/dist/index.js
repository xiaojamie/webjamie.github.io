'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var parser = require('@astrojs/parser');
var _doc = require('prettier/doc');
var sassFormatter = require('sass-formatter');
var prettier = require('prettier');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _doc__default = /*#__PURE__*/_interopDefaultLegacy(_doc);

const parse = (text) => parser.parse(text);

const options = {
    astroSortOrder: {
        since: '0.0.1',
        category: 'Astro',
        type: 'choice',
        default: 'markup | styles',
        description: 'Sort order for markup, scripts, and styles',
        choices: [
            {
                value: 'markup | styles',
                description: 'markup | styles',
            },
            {
                value: 'styles | markup',
                description: 'styles | markup',
            },
        ],
    },
    astroAllowShorthand: {
        since: '0.0.10',
        category: 'Astro',
        type: 'boolean',
        default: true,
        description: 'Enable/disable attribute shorthand if attribute name and expression are the same',
    },
};
const parseSortOrder = (sortOrder) => sortOrder.split(' | ');

const blockElementsT = [
    'address',
    'article',
    'aside',
    'blockquote',
    'details',
    'dialog',
    'dd',
    'div',
    'dl',
    'dt',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'hr',
    'li',
    'main',
    'nav',
    'ol',
    'p',
    'pre',
    'section',
    'table',
    'ul',
];
const blockElements = [...blockElementsT];
const selfClosingTags = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

const formattableAttributes = [];
const rootNodeKeys = new Set(['html', 'css', 'module']);
const isASTNode = (node) => typeof node === 'object' && Object.keys(node).filter((key) => rootNodeKeys.has(key)).length === rootNodeKeys.size;
const isEmptyTextNode = (node) => {
    return !!node && node.type === 'Text' && getUnencodedText(node).trim() === '';
};
const isPreTagContent = (path) => {
    if (!path || !path.stack || !Array.isArray(path.stack))
        return false;
    return path.stack.some((node) => (node.type === 'Element' && node.name.toLowerCase() === 'pre') || (node.type === 'Attribute' && !formattableAttributes.includes(node.name)));
};
function isLoneMustacheTag(node) {
    return node !== true && node.length === 1 && node[0].type === 'MustacheTag';
}
function isAttributeShorthand(node) {
    return node !== true && node.length === 1 && node[0].type === 'AttributeShorthand';
}
function isOrCanBeConvertedToShorthand(node, opts) {
    if (!opts.astroAllowShorthand)
        return false;
    if (isAttributeShorthand(node.value)) {
        return true;
    }
    if (isLoneMustacheTag(node.value)) {
        const expression = node.value[0].expression;
        return expression.codeChunks[0].trim() === node.name;
    }
    return false;
}
function isShorthandAndMustBeConvertedToBinaryExpression(node, opts) {
    if (opts.astroAllowShorthand)
        return false;
    if (isAttributeShorthand(node.value)) {
        return true;
    }
    return false;
}
function getText(node, opts) {
    return opts.originalText.slice(opts.locStart(node), opts.locEnd(node));
}
function getUnencodedText(node) {
    return node.raw || node.data;
}
function replaceEndOfLineWith(text, replacement) {
    const parts = [];
    for (const part of text.split('\n')) {
        if (parts.length > 0) {
            parts.push(replacement);
        }
        if (part.endsWith('\r')) {
            parts.push(part.slice(0, -1));
        }
        else {
            parts.push(part);
        }
    }
    return parts;
}
function printRaw(node, originalText, stripLeadingAndTrailingNewline = false) {
    if (!isNodeWithChildren(node)) {
        return '';
    }
    if (node.children.length === 0) {
        return '';
    }
    const firstChild = node.children[0];
    const lastChild = node.children[node.children.length - 1];
    let raw = originalText.substring(firstChild.start, lastChild.end);
    if (!stripLeadingAndTrailingNewline) {
        return raw;
    }
    if (startsWithLinebreak(raw)) {
        raw = raw.substring(raw.indexOf('\n') + 1);
    }
    if (endsWithLinebreak(raw)) {
        raw = raw.substring(0, raw.lastIndexOf('\n'));
        if (raw.charAt(raw.length - 1) === '\r') {
            raw = raw.substring(0, raw.length - 1);
        }
    }
    return raw;
}
function isNodeWithChildren(node) {
    return node && Array.isArray(node.children);
}
function isInlineElement(path, opts, node) {
    return node && node.type === 'Element' && !isBlockElement(node, opts) && !isPreTagContent(path);
}
function isBlockElement(node, opts) {
    return node && node.type === 'Element' && opts.htmlWhitespaceSensitivity !== 'strict' && (opts.htmlWhitespaceSensitivity === 'ignore' || blockElements.includes(node.name));
}
function isTextNodeStartingWithLinebreak(node, nrLines = 1) {
    return startsWithLinebreak(getUnencodedText(node), nrLines);
}
function startsWithLinebreak(text, nrLines = 1) {
    return new RegExp(`^([\\t\\f\\r ]*\\n){${nrLines}}`).test(text);
}
function endsWithLinebreak(text, nrLines = 1) {
    return new RegExp(`(\\n[\\t\\f\\r ]*){${nrLines}}$`).test(text);
}
function isTextNodeStartingWithWhitespace(node) {
    return node.type === 'Text' && /^\s/.test(getUnencodedText(node));
}
function isTextNodeEndingWithWhitespace(node) {
    return node.type === 'Text' && /\s$/.test(getUnencodedText(node));
}
function forceIntoExpression(statement) {
    return `(${statement}\n)`;
}
function shouldHugStart(node, opts) {
    if (isBlockElement(node, opts)) {
        return false;
    }
    if (!isNodeWithChildren(node)) {
        return false;
    }
    const children = node.children;
    if (children.length === 0) {
        return true;
    }
    const firstChild = children[0];
    return !isTextNodeStartingWithWhitespace(firstChild);
}
function shouldHugEnd(node, opts) {
    if (isBlockElement(node, opts)) {
        return false;
    }
    if (!isNodeWithChildren(node)) {
        return false;
    }
    const children = node.children;
    if (children.length === 0) {
        return true;
    }
    const lastChild = children[children.length - 1];
    return !isTextNodeEndingWithWhitespace(lastChild);
}
function canOmitSoftlineBeforeClosingTag(path, opts) {
    return isLastChildWithinParentBlockElement(path, opts);
}
function getChildren(node) {
    return isNodeWithChildren(node) ? node.children : [];
}
function isLastChildWithinParentBlockElement(path, opts) {
    const parent = path.getParentNode();
    if (!parent || !isBlockElement(parent, opts)) {
        return false;
    }
    const children = getChildren(parent);
    const lastChild = children[children.length - 1];
    return lastChild === path.getNode();
}
function trimTextNodeLeft(node) {
    node.raw = node.raw && node.raw.trimLeft();
    node.data = node.data && node.data.trimLeft();
}
function trimTextNodeRight(node) {
    node.raw = node.raw && node.raw.trimRight();
    node.data = node.data && node.data.trimRight();
}
function findLastIndex(isMatch, items) {
    for (let i = items.length - 1; i >= 0; i--) {
        if (isMatch(items[i], i)) {
            return i;
        }
    }
    return -1;
}
function trimChildren(children) {
    let firstNonEmptyNode = children.findIndex((n) => !isEmptyTextNode(n));
    firstNonEmptyNode = firstNonEmptyNode === -1 ? children.length - 1 : firstNonEmptyNode;
    let lastNonEmptyNode = findLastIndex((n, idx) => {
        return !isEmptyTextNode(n);
    }, children);
    lastNonEmptyNode = lastNonEmptyNode === -1 ? 0 : lastNonEmptyNode;
    for (let i = 0; i <= firstNonEmptyNode; i++) {
        const n = children[i];
        if (isTextNode(n)) {
            trimTextNodeLeft(n);
        }
    }
    for (let i = children.length - 1; i >= lastNonEmptyNode; i--) {
        const n = children[i];
        if (isTextNode(n)) {
            trimTextNodeRight(n);
        }
    }
}
function isHardline(docToCheck) {
    return docToCheck === prettier.doc.builders.hardline || deepEqual(docToCheck, prettier.doc.builders.hardline);
}
function deepEqual(x, y) {
    if (x === y) {
        return true;
    }
    else if (typeof x == 'object' && x != null && typeof y == 'object' && y != null) {
        if (Object.keys(x).length != Object.keys(y).length)
            return false;
        for (var prop in x) {
            if (Object.prototype.hasOwnProperty.call(y, prop)) {
                if (!deepEqual(x[prop], y[prop]))
                    return false;
            }
            else {
                return false;
            }
        }
        return true;
    }
    else {
        return false;
    }
}
function isLine(docToCheck) {
    return (isHardline(docToCheck) ||
        (typeof docToCheck === 'object' && isDocCommand(docToCheck) && docToCheck.type === 'line') ||
        (typeof docToCheck === 'object' && isDocCommand(docToCheck) && docToCheck.type === 'concat' && docToCheck.parts.every(isLine)));
}
function isEmptyDoc(doc) {
    if (typeof doc === 'string') {
        return doc.length === 0;
    }
    if (Array.isArray(doc)) {
        return doc.length === 0;
    }
    return false;
}
function trim(docs, isWhitespace) {
    trimLeft(docs, isWhitespace);
    trimRight(docs, isWhitespace);
    return docs;
}
function trimLeft(group, isWhitespace) {
    let firstNonWhitespace = group.findIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc));
    if (firstNonWhitespace < 0 && group.length) {
        firstNonWhitespace = group.length;
    }
    if (firstNonWhitespace > 0) {
        const removed = group.splice(0, firstNonWhitespace);
        if (removed.every(isEmptyDoc)) {
            return trimLeft(group, isWhitespace);
        }
    }
    else {
        const parts = getParts(group[0]);
        if (parts) {
            return trimLeft(parts, isWhitespace);
        }
    }
}
function trimRight(group, isWhitespace) {
    let lastNonWhitespace = group.length ? findLastIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc), group) : 0;
    if (lastNonWhitespace < group.length - 1) {
        const removed = group.splice(lastNonWhitespace + 1);
        if (removed.every(isEmptyDoc)) {
            return trimRight(group, isWhitespace);
        }
    }
    else {
        const parts = getParts(group[group.length - 1]);
        if (parts) {
            return trimRight(parts, isWhitespace);
        }
    }
}
function getParts(doc) {
    if (typeof doc === 'object') {
        if (Array.isArray(doc)) {
            return doc;
        }
        if (doc.type === 'fill' || doc.type === 'concat') {
            return doc.parts;
        }
        if (doc.type === 'group') {
            return getParts(doc.contents);
        }
    }
}
function attachCommentsHTML(node) {
    if (!isNodeWithChildren(node) || !node.children.some(({ type }) => type === 'Comment'))
        return;
    const nodesToRemove = [];
    for (let n = 0; n < node.children.length - 1; n++) {
        if (!node.children[n])
            continue;
        if (node.children[n].type === 'Comment') {
            let next = n + 1;
            while (isEmptyTextNode(node.children[next])) {
                nodesToRemove.push(next);
                next++;
            }
            const commentNode = node.children[next];
            if (commentNode) {
                const comment = node.children[n];
                prettier.util.addLeadingComment(commentNode, comment);
            }
        }
    }
    nodesToRemove.reverse();
    nodesToRemove.forEach((index) => {
        node.children.splice(index, 1);
    });
}
function dedent$1(input) {
    let minTabSize = Infinity;
    let result = input;
    result = result.replace(/\r\n/g, '\n');
    let char = '';
    for (const line of result.split('\n')) {
        if (!line)
            continue;
        if (line[0] && /^[^\s]/.test(line[0])) {
            minTabSize = 0;
            break;
        }
        const match = line.match(/^(\s+)\S+/);
        if (match) {
            if (match[1] && !char)
                char = match[1][0];
            if (match[1].length < minTabSize)
                minTabSize = match[1].length;
        }
    }
    if (minTabSize > 0 && Number.isFinite(minTabSize)) {
        result = result.replace(new RegExp(`^${new Array(minTabSize + 1).join(char)}`, 'gm'), '');
    }
    return {
        tabSize: minTabSize === Infinity ? 0 : minTabSize,
        char,
        result,
    };
}
function getMarkdownName(script) {
    let defaultMatch;
    while ((defaultMatch = /import\s+([^\s]+)\s+from\s+['|"|`]astro\/components\/Markdown\.astro/g.exec(script))) {
        if (defaultMatch[1])
            return new Set([defaultMatch[1].trim()]);
    }
    let namedMatch;
    while ((namedMatch = /import\s+\{\s*([^}]+)\}\s+from\s+['|"|`]astro\/components/g.exec(script))) {
        if (namedMatch[1] && !namedMatch[1].includes('Markdown'))
            continue;
        const rawImports = namedMatch[1].trim().replace(/^\{/, '').replace(/\}$/, '').trim();
        let importName = 'Markdown';
        for (const spec of rawImports.split(',')) {
            const [original, renamed] = spec.split(' as ').map((s) => s.trim());
            if (original !== 'Markdown')
                continue;
            importName = renamed || original;
            break;
        }
        return new Set([importName]);
    }
    return new Set(['Markdown']);
}
function isTextNode(node) {
    return node.type === 'Text';
}
function isDocCommand(doc) {
    if (typeof doc === 'string')
        return false;
    if (Array.isArray(doc))
        return false;
    return true;
}
function isInsideQuotedAttribute(path) {
    const stack = path.stack;
    return stack.some((node) => node.type === 'Attribute' && !isLoneMustacheTag(node.value));
}

const { builders: { breakParent, dedent, fill, group, hardline, indent, join, line, literalline, softline }, utils: { removeLines, stripTrailingHardline }, } = _doc__default["default"];
function printTopLevelParts(node, path, opts, print) {
    let docs = [];
    const normalize = (doc) => [stripTrailingHardline(doc), hardline];
    if (node.module) {
        const subDoc = normalize(path.call(print, 'module'));
        docs.push(subDoc);
    }
    for (const section of parseSortOrder(opts.astroSortOrder)) {
        switch (section) {
            case 'markup': {
                const subDoc = path.call(print, 'html');
                if (!isEmptyDoc(subDoc))
                    docs.push(normalize(subDoc));
                break;
            }
            case 'styles': {
                const subDoc = path.call(print, 'css');
                if (!isEmptyDoc(subDoc))
                    docs.push(normalize(subDoc));
                break;
            }
        }
    }
    return join(softline, docs);
}
function printAttributeNodeValue(path, print, quotes, node) {
    const valueDocs = path.map((childPath) => childPath.call(print), 'value');
    if (!quotes || !formattableAttributes.includes(node.name)) {
        return valueDocs;
    }
    else {
        return indent(group(trim(valueDocs, isLine)));
    }
}
function printJS(path, print, name, { forceSingleQuote, forceSingleLine }) {
    path.getValue()[name].isJS = true;
    path.getValue()[name].forceSingleQuote = forceSingleQuote;
    path.getValue()[name].forceSingleLine = forceSingleLine;
    return path.call(print, name);
}
function printComment(commentPath, options) {
    return commentPath;
}
function print(path, opts, print) {
    var _a, _b;
    const node = path.getValue();
    const isMarkdownSubDoc = opts.parentParser === 'markdown';
    if (!node) {
        return '';
    }
    if (typeof node === 'string') {
        return node;
    }
    if (Array.isArray(node)) {
        return path.map((childPath) => childPath.call(print));
    }
    if (isASTNode(node)) {
        return printTopLevelParts(node, path, opts, print);
    }
    if (!isPreTagContent(path) && !isMarkdownSubDoc && node.type === 'Fragment') {
        attachCommentsHTML(node);
    }
    switch (node.type) {
        case 'Fragment': {
            const text = getText(node, opts);
            if (text.length === 0) {
                return '';
            }
            if (!isNodeWithChildren(node) || node.children.every(isEmptyTextNode))
                return '';
            if (!isPreTagContent(path)) {
                trimChildren(node.children);
                const output = trim([path.map(print, 'children')], (n) => isLine(n) ||
                    (typeof n === 'string' && n.trim() === '') ||
                    n === breakParent);
                if (output.every((doc) => isEmptyDoc(doc))) {
                    return '';
                }
                return group([...output, hardline]);
            }
            else {
                return group(path.map(print, 'children'));
            }
        }
        case 'Text': {
            const rawText = getUnencodedText(node);
            if (isPreTagContent(path)) {
                if (((_a = path.getParentNode()) === null || _a === void 0 ? void 0 : _a.type) === 'Attribute') {
                    return replaceEndOfLineWith(rawText, literalline);
                }
                return rawText;
            }
            if (isEmptyTextNode(node)) {
                const hasWhiteSpace = rawText.trim().length < getUnencodedText(node).length;
                const hasOneOrMoreNewlines = /\n/.test(getUnencodedText(node));
                const hasTwoOrMoreNewlines = /\n\r?\s*\n\r?/.test(getUnencodedText(node));
                if (hasTwoOrMoreNewlines) {
                    return [hardline, hardline];
                }
                if (hasOneOrMoreNewlines) {
                    return hardline;
                }
                if (hasWhiteSpace) {
                    return line;
                }
                return '';
            }
            return fill(splitTextToDocs(node));
        }
        case 'Element':
        case 'InlineComponent':
        case 'Slot': {
            const isEmpty = (_b = node.children) === null || _b === void 0 ? void 0 : _b.every((child) => isEmptyTextNode(child));
            const isSelfClosingTag = isEmpty && (node.type !== 'Element' || selfClosingTags.indexOf(node.name) !== -1);
            const attributes = path.map(print, 'attributes');
            if (isSelfClosingTag) {
                return group(['<', node.name, indent(group(attributes)), line, `/>`]);
            }
            try {
                if (node.name.toLowerCase() === '!doctype') {
                    const attributesWithLowercaseHTML = attributes.map((attribute) => {
                        if (typeof attribute === 'string')
                            return attribute;
                        if (isDocCommand(attribute))
                            return attribute;
                        attribute = attribute.map((attrValue) => {
                            if (typeof attrValue !== 'string')
                                return attrValue;
                            if (attrValue.toLowerCase() === 'html') {
                                attrValue = attrValue.toLowerCase();
                            }
                            return attrValue;
                        });
                        return attribute;
                    });
                    return group(['<', node.name.toUpperCase(), ...attributesWithLowercaseHTML, `>`]);
                }
            }
            catch (e) {
                console.warn(`error ${e} in the doctype printing`);
            }
            if (node.children) {
                const children = node.children;
                const firstChild = children[0];
                const lastChild = children[children.length - 1];
                let noHugSeparatorStart = softline;
                let noHugSeparatorEnd = softline;
                let hugStart = shouldHugStart(node, opts);
                let hugEnd = shouldHugEnd(node, opts);
                let body;
                if (isEmpty) {
                    body =
                        isInlineElement(path, opts, node) && node.children.length && isTextNodeStartingWithWhitespace(node.children[0]) && !isPreTagContent(path)
                            ? () => line
                            :
                                () => softline;
                }
                else if (isPreTagContent(path)) {
                    body = () => printRaw(node, opts.originalText);
                }
                else if (isInlineElement(path, opts, node) && !isPreTagContent(path)) {
                    body = () => path.map(print, 'children');
                }
                else {
                    body = () => path.map(print, 'children');
                }
                const openingTag = ['<', node.name, indent(group([...attributes, hugStart ? '' : !isPreTagContent(path) && !opts.bracketSameLine ? dedent(softline) : '']))];
                if (hugStart && hugEnd) {
                    const huggedContent = [softline, group(['>', body(), `</${node.name}`])];
                    const omitSoftlineBeforeClosingTag = isEmpty || canOmitSoftlineBeforeClosingTag(path, opts);
                    return group([...openingTag, isEmpty ? group(huggedContent) : group(indent(huggedContent)), omitSoftlineBeforeClosingTag ? '' : softline, '>']);
                }
                if (isPreTagContent(path)) {
                    noHugSeparatorStart = '';
                    noHugSeparatorEnd = '';
                }
                else {
                    let didSetEndSeparator = false;
                    if (!hugStart && firstChild && isTextNode(firstChild)) {
                        if (isTextNodeStartingWithLinebreak(firstChild) && firstChild !== lastChild && (!isInlineElement(path, opts, node) || isTextNodeEndingWithWhitespace(lastChild))) {
                            noHugSeparatorStart = hardline;
                            noHugSeparatorEnd = hardline;
                            didSetEndSeparator = true;
                        }
                        else if (isInlineElement(path, opts, node)) {
                            noHugSeparatorStart = line;
                        }
                        trimTextNodeLeft(firstChild);
                    }
                    if (!hugEnd && lastChild && isTextNode(lastChild)) {
                        if (isInlineElement(path, opts, node) && !didSetEndSeparator) {
                            noHugSeparatorEnd = line;
                        }
                        trimTextNodeRight(lastChild);
                    }
                }
                if (hugStart) {
                    return group([...openingTag, indent([softline, group(['>', body()])]), noHugSeparatorEnd, `</${node.name}>`]);
                }
                if (hugEnd) {
                    return group([...openingTag, '>', indent([noHugSeparatorStart, group([body(), `</${node.name}`])]), canOmitSoftlineBeforeClosingTag(path, opts) ? '' : softline, '>']);
                }
                if (isEmpty) {
                    return group([...openingTag, '>', body(), `</${node.name}>`]);
                }
                return group([...openingTag, '>', indent([noHugSeparatorStart, body()]), noHugSeparatorEnd, `</${node.name}>`]);
            }
        }
        case 'AttributeShorthand': {
            return node.expression.name;
        }
        case 'Attribute': {
            if (isOrCanBeConvertedToShorthand(node, opts)) {
                return [line, '{', node.name, '}'];
            }
            else if (isShorthandAndMustBeConvertedToBinaryExpression(node, opts)) {
                const attrNodeValue = printAttributeNodeValue(path, print, true, node);
                return [line, node.name, '=', '{', attrNodeValue, '}'];
            }
            else if (node.value === true) {
                return [line, node.name];
            }
            const quotes = !isLoneMustacheTag(node.value);
            const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);
            if (quotes) {
                return [line, node.name, '=', '"', attrNodeValue, '"'];
            }
            else {
                return [line, node.name, '=', attrNodeValue];
            }
        }
        case 'Expression':
            return [];
        case 'MustacheTag':
            return [
                '{',
                printJS(path, print, 'expression', {
                    forceSingleLine: isInsideQuotedAttribute(path),
                    forceSingleQuote: opts.jsxSingleQuote,
                }),
                '}',
            ];
        case 'Spread':
            return [
                line,
                '{...',
                printJS(path, print, 'expression', {
                    forceSingleQuote: true,
                    forceSingleLine: false,
                }),
                '}',
            ];
        case 'Comment':
            return ['<!--', getUnencodedText(node), '-->'];
        case 'CodeSpan':
            return getUnencodedText(node);
        case 'CodeFence': {
            console.debug(node);
            return [node.metadata, hardline, node.data, hardline, '```', hardline];
        }
        default: {
            throw new Error(`Unhandled node type "${node.type}"!`);
        }
    }
}
function splitTextToDocs(node) {
    const text = getUnencodedText(node);
    let textLines = text.split(/[\t\n\f\r ]+/);
    let docs = join(line, textLines).parts.filter((s) => s !== '');
    if (startsWithLinebreak(text)) {
        docs[0] = hardline;
    }
    if (startsWithLinebreak(text, 2)) {
        docs = [hardline, ...docs];
    }
    if (endsWithLinebreak(text)) {
        docs[docs.length - 1] = hardline;
    }
    if (endsWithLinebreak(text, 2)) {
        docs = [...docs, hardline];
    }
    return docs;
}
function expressionParser(text, parsers, opts) {
    const ast = parsers.babel(text, parsers, opts);
    return { ...ast, program: ast.program.body[0].expression };
}
let markdownComponentName = new Set();
function embed(path, print, textToDoc, opts) {
    if (!opts.__astro)
        opts.__astro = {};
    const node = path.getValue();
    if (!node)
        return null;
    if (node.isJS) {
        try {
            const embeddedopts = {
                parser: expressionParser,
            };
            if (node.forceSingleQuote) {
                embeddedopts.singleQuote = true;
            }
            const docs = textToDoc(forceIntoExpression(getText(node, opts)), embeddedopts);
            return node.forceSingleLine ? removeLines(docs) : docs;
        }
        catch (e) {
            return getText(node, opts);
        }
    }
    if (node.type === 'Script' && node.context === 'setup') {
        markdownComponentName = getMarkdownName(node.content);
        return group(['---', hardline, textToDoc(node.content, { ...opts, parser: 'typescript' }), '---', hardline]);
    }
    if (isTextNode(node)) {
        const parent = path.getParentNode();
        if (parent && parent.type === 'Element' && parent.name === 'script') {
            const formatttedScript = textToDoc(node.data, { ...opts, parser: 'typescript' });
            return stripTrailingHardline(formatttedScript);
        }
    }
    if (node.type === 'Style' || (node.type === 'Element' && node.name === 'style')) {
        let styleTagContent = '';
        if (node.type === 'Style') {
            styleTagContent = node.content.styles;
        }
        else if (node.children) {
            const children = node.children[0];
            styleTagContent = getUnencodedText(children);
        }
        const supportedStyleLangValues = ['css', 'scss', 'sass'];
        let parserLang = 'css';
        if ('attributes' in node) {
            const langAttribute = node.attributes.filter((x) => x.name === 'lang');
            if (langAttribute.length) {
                const styleLang = langAttribute[0].value[0].raw.toLowerCase();
                if (supportedStyleLangValues.includes(styleLang))
                    parserLang = styleLang;
            }
        }
        switch (parserLang) {
            case 'css':
            case 'scss': {
                let formattedStyles = textToDoc(styleTagContent, { ...opts, parser: parserLang });
                formattedStyles = stripTrailingHardline(formattedStyles);
                const attributes = path.map(print, 'attributes');
                const openingTag = group(['<style', indent(group(attributes)), softline, '>']);
                return [openingTag, indent([hardline, formattedStyles]), hardline, '</style>'];
            }
            case 'sass': {
                const lineEnding = opts.endOfLine.toUpperCase() === 'CRLF' ? 'CRLF' : 'LF';
                const sassOptions = {
                    tabSize: opts.tabWidth,
                    insertSpaces: !opts.useTabs,
                    lineEnding,
                };
                const { result: raw } = dedent$1(styleTagContent);
                let formattedSassIndented = sassFormatter.SassFormatter.Format(raw, sassOptions).trim();
                const formattedSass = join(hardline, formattedSassIndented.split('\n'));
                const attributes = path.map(print, 'attributes');
                const openingTag = group(['<style', indent(group(attributes)), softline, '>']);
                return [openingTag, indent(group([hardline, formattedSass])), hardline, '</style>'];
            }
        }
    }
    if (node.type === 'InlineComponent' && markdownComponentName.has(node.name)) {
        let content = printRaw(node, opts.originalText);
        content = content.replace(/\r\n/g, '\n');
        const contentArr = content.split('\n').map((s) => s.trimStart());
        content = contentArr.join('\n');
        let formatttedMarkdown = textToDoc(content, { ...opts, parser: 'markdown' });
        formatttedMarkdown = stripTrailingHardline(formatttedMarkdown);
        const attributes = path.map(print, 'attributes');
        const openingTag = group([`<${node.name}`, indent(group(attributes)), softline, '>']);
        return [openingTag, indent(group([hardline, formatttedMarkdown])), hardline, `</${node.name}>`];
    }
    return null;
}
function hasPrettierIgnore(path) {
    const node = path.getNode();
    if (!node || !Array.isArray(node.comments))
        return false;
    const hasIgnore = node.comments.some((comment) => comment.data.includes('prettier-ignore') && !comment.data.includes('prettier-ignore-start') && !comment.data.includes('prettier-ignore-end'));
    return hasIgnore;
}
const printer = {
    print,
    printComment,
    embed,
    hasPrettierIgnore,
};

const languages = [
    {
        name: 'astro',
        parsers: ['astro'],
        extensions: ['.astro'],
        vscodeLanguageIds: ['astro'],
    },
];
const parsers = {
    astro: {
        parse,
        astFormat: 'astro',
        locStart: (node) => node.start,
        locEnd: (node) => node.end,
    },
};
const printers = {
    astro: printer,
};
const defaultOptions = {
    tabWidth: 2,
};

exports.defaultOptions = defaultOptions;
exports.languages = languages;
exports.options = options;
exports.parsers = parsers;
exports.printers = printers;
//# sourceMappingURL=index.js.map
