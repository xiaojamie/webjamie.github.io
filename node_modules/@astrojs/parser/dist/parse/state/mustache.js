var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var mustache_exports = {};
__export(mustache_exports, {
  default: () => mustache
});
var import_context = __toESM(require("../read/context.js"));
var import_expression = __toESM(require("../read/expression.js"));
var import_html = require("../utils/html.js");
var import_patterns = require("../../utils/patterns.js");
var import_node = require("../utils/node.js");
function trim_whitespace(block, trim_before, trim_after) {
  if (!block.children || block.children.length === 0)
    return;
  const first_child = block.children[0];
  const last_child = block.children[block.children.length - 1];
  if (first_child.type === "Text" && trim_before) {
    first_child.data = first_child.data.trimStart();
    if (!first_child.data)
      block.children.shift();
  }
  if (last_child.type === "Text" && trim_after) {
    last_child.data = last_child.data.trimEnd();
    if (!last_child.data)
      block.children.pop();
  }
  if (block.else) {
    trim_whitespace(block.else, trim_before, trim_after);
  }
  if (first_child.elseif) {
    trim_whitespace(first_child, trim_before, trim_after);
  }
}
function mustache(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("/")) {
    let block = parser.current();
    let expected;
    if ((0, import_html.closing_tag_omitted)(block.name)) {
      block.end = start;
      parser.stack.pop();
      block = parser.current();
    }
    if (block.type === "ElseBlock" || block.type === "PendingBlock" || block.type === "ThenBlock" || block.type === "CatchBlock") {
      block.end = start;
      parser.stack.pop();
      block = parser.current();
      expected = "await";
    }
    if (block.type === "IfBlock") {
      expected = "if";
    } else if (block.type === "EachBlock") {
      expected = "each";
    } else if (block.type === "AwaitBlock") {
      expected = "await";
    } else if (block.type === "KeyBlock") {
      expected = "key";
    } else {
      parser.error({
        code: "unexpected-block-close",
        message: "Unexpected block closing tag"
      });
    }
    parser.eat(expected, true);
    parser.allow_whitespace();
    parser.eat("}", true);
    while (block.elseif) {
      block.end = parser.index;
      parser.stack.pop();
      block = parser.current();
      if (block.else) {
        block.else.end = start;
      }
    }
    const char_before = parser.template[block.start - 1];
    const char_after = parser.template[parser.index];
    const trim_before = !char_before || import_patterns.whitespace.test(char_before);
    const trim_after = !char_after || import_patterns.whitespace.test(char_after);
    trim_whitespace(block, trim_before, trim_after);
    block.end = parser.index;
    parser.stack.pop();
  } else if (parser.eat(":else")) {
    if (parser.eat("if")) {
      parser.error({
        code: "invalid-elseif",
        message: "'elseif' should be 'else if'"
      });
    }
    parser.allow_whitespace();
    if (parser.eat("if")) {
      const block = parser.current();
      if (block.type !== "IfBlock") {
        parser.error({
          code: "invalid-elseif-placement",
          message: parser.stack.some((block2) => block2.type === "IfBlock") ? `Expected to close ${(0, import_node.to_string)(block)} before seeing {:else if ...} block` : "Cannot have an {:else if ...} block outside an {#if ...} block"
        });
      }
      parser.require_whitespace();
      const expression = (0, import_expression.default)(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      block.else = {
        start: parser.index,
        end: null,
        type: "ElseBlock",
        children: [
          {
            start: parser.index,
            end: null,
            type: "IfBlock",
            elseif: true,
            expression,
            children: []
          }
        ]
      };
      parser.stack.push(block.else.children[0]);
    } else {
      const block = parser.current();
      if (block.type !== "IfBlock" && block.type !== "EachBlock") {
        parser.error({
          code: "invalid-else-placement",
          message: parser.stack.some((block2) => block2.type === "IfBlock" || block2.type === "EachBlock") ? `Expected to close ${(0, import_node.to_string)(block)} before seeing {:else} block` : "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
        });
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      block.else = {
        start: parser.index,
        end: null,
        type: "ElseBlock",
        children: []
      };
      parser.stack.push(block.else);
    }
  } else if (parser.match(":then") || parser.match(":catch")) {
    const block = parser.current();
    const is_then = parser.eat(":then") || !parser.eat(":catch");
    if (is_then) {
      if (block.type !== "PendingBlock") {
        parser.error({
          code: "invalid-then-placement",
          message: parser.stack.some((block2) => block2.type === "PendingBlock") ? `Expected to close ${(0, import_node.to_string)(block)} before seeing {:then} block` : "Cannot have an {:then} block outside an {#await ...} block"
        });
      }
    } else {
      if (block.type !== "ThenBlock" && block.type !== "PendingBlock") {
        parser.error({
          code: "invalid-catch-placement",
          message: parser.stack.some((block2) => block2.type === "ThenBlock" || block2.type === "PendingBlock") ? `Expected to close ${(0, import_node.to_string)(block)} before seeing {:catch} block` : "Cannot have an {:catch} block outside an {#await ...} block"
        });
      }
    }
    block.end = start;
    parser.stack.pop();
    const await_block = parser.current();
    if (!parser.eat("}")) {
      parser.require_whitespace();
      await_block[is_then ? "value" : "error"] = (0, import_context.default)(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    const new_block = {
      start,
      end: null,
      type: is_then ? "ThenBlock" : "CatchBlock",
      children: [],
      skip: false
    };
    await_block[is_then ? "then" : "catch"] = new_block;
    parser.stack.push(new_block);
  } else if (parser.eat("#")) {
    let type;
    if (parser.eat("if")) {
      type = "IfBlock";
    } else if (parser.eat("each")) {
      type = "EachBlock";
    } else if (parser.eat("await")) {
      type = "AwaitBlock";
    } else if (parser.eat("key")) {
      type = "KeyBlock";
    } else {
      parser.error({
        code: "expected-block-type",
        message: "Expected if, each, await or key"
      });
    }
    parser.require_whitespace();
    const expression = (0, import_expression.default)(parser);
    const block = type === "AwaitBlock" ? {
      start,
      end: null,
      type,
      expression,
      value: null,
      error: null,
      pending: {
        start: null,
        end: null,
        type: "PendingBlock",
        children: [],
        skip: true
      },
      then: {
        start: null,
        end: null,
        type: "ThenBlock",
        children: [],
        skip: true
      },
      catch: {
        start: null,
        end: null,
        type: "CatchBlock",
        children: [],
        skip: true
      }
    } : {
      start,
      end: null,
      type,
      expression,
      children: []
    };
    parser.allow_whitespace();
    if (type === "EachBlock") {
      parser.eat("as", true);
      parser.require_whitespace();
      block.context = (0, import_context.default)(parser);
      parser.allow_whitespace();
      if (parser.eat(",")) {
        parser.allow_whitespace();
        block.index = parser.read_identifier();
        if (!block.index) {
          parser.error({
            code: "expected-name",
            message: "Expected name"
          });
        }
        parser.allow_whitespace();
      }
      if (parser.eat("(")) {
        parser.allow_whitespace();
        block.key = (0, import_expression.default)(parser);
        parser.allow_whitespace();
        parser.eat(")", true);
        parser.allow_whitespace();
      }
    }
    const await_block_shorthand = type === "AwaitBlock" && parser.eat("then");
    if (await_block_shorthand) {
      parser.require_whitespace();
      block.value = (0, import_context.default)(parser);
      parser.allow_whitespace();
    }
    const await_block_catch_shorthand = !await_block_shorthand && type === "AwaitBlock" && parser.eat("catch");
    if (await_block_catch_shorthand) {
      parser.require_whitespace();
      block.error = (0, import_context.default)(parser);
      parser.allow_whitespace();
    }
    parser.eat("}", true);
    parser.current().children.push(block);
    parser.stack.push(block);
    if (type === "AwaitBlock") {
      let child_block;
      if (await_block_shorthand) {
        block.then.skip = false;
        child_block = block.then;
      } else if (await_block_catch_shorthand) {
        block.catch.skip = false;
        child_block = block.catch;
      } else {
        block.pending.skip = false;
        child_block = block.pending;
      }
      child_block.start = parser.index;
      parser.stack.push(child_block);
    }
  } else if (parser.eat("@html")) {
    parser.require_whitespace();
    const expression = (0, import_expression.default)(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "RawMustacheTag",
      expression
    });
  } else if (parser.eat("@debug")) {
    throw new Error("@debug not yet supported");
  } else {
    const expression = (0, import_expression.default)(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "MustacheTag",
      expression
    });
  }
}
module.exports = __toCommonJS(mustache_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL3BhcnNlL3N0YXRlL211c3RhY2hlLnRzIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFBeUI7QUFDekIsd0JBQTRCO0FBQzVCLGtCQUFvQztBQUNwQyxzQkFBMkI7QUFDM0Isa0JBQTBCO0FBTTFCLHlCQUF5QixPQUFxQixhQUFzQixZQUFxQjtBQUN4RixNQUFJLENBQUMsTUFBTSxZQUFZLE1BQU0sU0FBUyxXQUFXO0FBQUc7QUFFcEQsUUFBTSxjQUFjLE1BQU0sU0FBUztBQUNuQyxRQUFNLGFBQWEsTUFBTSxTQUFTLE1BQU0sU0FBUyxTQUFTO0FBRTFELE1BQUksWUFBWSxTQUFTLFVBQVUsYUFBYTtBQUMvQyxnQkFBWSxPQUFPLFlBQVksS0FBSyxVQUFVO0FBQzlDLFFBQUksQ0FBQyxZQUFZO0FBQU0sWUFBTSxTQUFTLE1BQU07QUFBQSxFQUM3QztBQUVBLE1BQUksV0FBVyxTQUFTLFVBQVUsWUFBWTtBQUM3QyxlQUFXLE9BQU8sV0FBVyxLQUFLLFFBQVE7QUFDMUMsUUFBSSxDQUFDLFdBQVc7QUFBTSxZQUFNLFNBQVMsSUFBSTtBQUFBLEVBQzFDO0FBRUEsTUFBSSxNQUFNLE1BQU07QUFDZixvQkFBZ0IsTUFBTSxNQUFNLGFBQWEsVUFBVTtBQUFBLEVBQ3BEO0FBRUEsTUFBSSxZQUFZLFFBQVE7QUFDdkIsb0JBQWdCLGFBQWEsYUFBYSxVQUFVO0FBQUEsRUFDckQ7QUFDRDtBQUVlLGtCQUFrQixRQUFnQjtBQUNoRCxRQUFNLFFBQVEsT0FBTztBQUNyQixTQUFPLFNBQVM7QUFFaEIsU0FBTyxpQkFBaUI7QUFHeEIsTUFBSSxPQUFPLElBQUksR0FBRyxHQUFHO0FBQ3BCLFFBQUksUUFBUSxPQUFPLFFBQVE7QUFDM0IsUUFBSTtBQUVKLFFBQUkscUNBQW9CLE1BQU0sSUFBSSxHQUFHO0FBQ3BDLFlBQU0sTUFBTTtBQUNaLGFBQU8sTUFB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
