var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var tag_exports = {};
__export(tag_exports, {
  default: () => tag,
  read_sequence: () => read_sequence
});
var import_expression = __toESM(require("../read/expression.js"));
var import_style = __toESM(require("../read/style.js"));
var import_html = require("../utils/html.js");
var import_names = require("../../utils/names.js");
var import_fuzzymatch = __toESM(require("../../utils/fuzzymatch.js"));
var import_list = __toESM(require("../../utils/list.js"));
var import_features = require("../utils/features.js");
const valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
const meta_tags = /* @__PURE__ */ new Map([
  ["astro:head", "Head"],
  ["", "SlotTemplate"]
]);
const valid_meta_tags = Array.from(meta_tags.keys());
const specials = /* @__PURE__ */ new Map([
  [
    "style",
    {
      read: import_style.default,
      property: "css"
    }
  ]
]);
const SELF = /^astro:self(?=[\s/>])/;
const COMPONENT = /^astro:component(?=[\s/>])/;
const SLOT = /^astro:fragment(?=[\s/>])/;
const HEAD = /^head(?=[\s/>])/;
const CUSTOM_ELEMENT = /-/;
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "Head")
      return true;
    if (type === "Element" || type === "InlineComponent")
      return false;
  }
  return false;
}
function tag(parser) {
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data = parser.read_until(/-->/);
    parser.eat("-->", true, "comment was left open, expected -->");
    parser.current().children.push({
      start,
      end: parser.index,
      type: "Comment",
      data
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name = read_tag_name(parser);
  if (CUSTOM_ELEMENT.test(name)) {
    parser.feature_flags |= import_features.FEATURE_CUSTOM_ELEMENT;
  }
  if (meta_tags.has(name)) {
    const slug = meta_tags.get(name).toLowerCase();
    if (is_closing_tag) {
      if ((name === "astro:window" || name === "astro:body") && parser.current().children.length) {
        parser.error({
          code: `invalid-${slug}-content`,
          message: `<${name}> cannot have children`
        }, parser.current().children[0].start);
      }
    } else {
      if (name in parser.meta_tags) {
        parser.error({
          code: `duplicate-${slug}`,
          message: `A component can only have one <${name}> tag`
        }, start);
      }
      if (parser.stack.length > 1) {
        parser.error({
          code: `invalid-${slug}-placement`,
          message: `<${name}> tags cannot be inside elements or blocks`
        }, start);
      }
      parser.meta_tags[name] = true;
    }
  }
  const type = meta_tags.has(name) ? meta_tags.get(name) : /[A-Z]/.test(name[0]) || name === "astro:self" || name === "astro:component" ? "InlineComponent" : name === "" ? "SlotTemplate" : name === "title" && parent_is_head(parser.stack) ? "Title" : name === "slot" && !parser.customElement ? "Slot" : "Element";
  const element = {
    start,
    end: null,
    type,
    name,
    attributes: [],
    children: []
  };
  parser.allow_whitespace();
  if (is_closing_tag) {
    if ((0, import_names.is_void)(name)) {
      parser.error({
        code: "invalid-void-content",
        message: `<${name}> is a void element and cannot have children, or a closing tag`
      }, start);
    }
    parser.eat(">", true);
    while (parent.name !== name) {
      if (parent.type !== "Element") {
        const message = parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name ? `</${name}> attempted to close <${name}> that was already automatically closed by <${parser.last_auto_closed_tag.reason}>` : `</${name}> attempted to close an element that was not open`;
        parser.error({
          code: "invalid-closing-tag",
          message
        }, start);
      }
      parent.end = start;
      parser.stack.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.stack.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = null;
    }
    return;
  } else if ((0, import_html.closing_tag_omitted)(parent.name, name)) {
    parent.end = start;
    parser.stack.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name,
      depth: parser.stack.length
    };
  }
  const unique_names = /* @__PURE__ */ new Set();
  let attribute;
  while (attribute = read_attribute(parser, unique_names)) {
    element.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (name === "astro:component") {
    const index = element.attributes.findIndex((attr) => attr.type === "Attribute" && attr.name === "this");
    if (!~index) {
      parser.error({
        code: "missing-component-definition",
        message: "<astro:component> must have a 'this' attribute"
      }, start);
    }
    const definition = element.attributes.splice(index, 1)[0];
    if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text") {
      parser.error({
        code: "invalid-component-definition",
        message: "invalid component definition"
      }, definition.start);
    }
    element.expression = definition.value[0].expression;
  }
  if (specials.has(name) && parser.stack.length === 1) {
    const special = specials.get(name);
    parser.eat(">", true);
    const content = special.read(parser, start, element.attributes);
    if (content)
      parser[special.property].push(content);
    return;
  }
  parser.current().children.push(element);
  const self_closing = parser.eat("/") || (0, import_names.is_void)(name);
  parser.eat(">", true);
  if (self_closing) {
    element.end = parser.index;
  } else if (name === "textarea") {
    element.children = read_sequence(parser, () => parser.template.slice(parser.index, parser.index + 11) === "</textarea>");
    parser.read(/<\/textarea>/);
    element.end = parser.index;
  } else if (name === "script" || name === "style") {
    const start2 = parser.index;
    const data = parser.read_until(new RegExp(`</${name}>`));
    const end = parser.index;
    element.children.push({ start: start2, end, type: "Text", data });
    parser.eat(`</${name}>`, true);
    element.end = parser.index;
  } else {
    parser.stack.push(element);
  }
}
function read_tag_name(parser) {
  const start = parser.index;
  if (parser.read(SELF)) {
    let i = parser.stack.length;
    let legal = false;
    while (i--) {
      const fragment = parser.stack[i];
      if (fragment.type === "IfBlock" || fragment.type === "EachBlock" || fragment.type === "InlineComponent") {
        legal = true;
        break;
      }
    }
    if (!legal) {
      parser.error({
        code: "invalid-self-placement",
        message: "<astro:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
      }, start);
    }
    return "astro:self";
  }
  if (parser.read(COMPONENT))
    return "astro:component";
  if (parser.read(SLOT))
    return "astro:fragment";
  if (parser.read(HEAD))
    return "head";
  const name = parser.read_until(/(\s|\/|>)/);
  if (meta_tags.has(name))
    return name;
  if (name.startsWith("astro:")) {
    const match = (0, import_fuzzymatch.default)(name.slice(7), valid_meta_tags);
    let message = `Valid <astro:...> tag names are ${(0, import_list.default)(valid_meta_tags)}`;
    if (match)
      message += ` (did you mean '${match}'?)`;
    parser.error({
      code: "invalid-tag-name",
      message
    }, start);
  }
  if (!valid_tag_name.test(name)) {
    parser.error({
      code: "invalid-tag-name",
      message: "Expected valid tag name"
    }, start);
  }
  return name;
}
function read_attribute(parser, unique_names) {
  const start = parser.index;
  function check_unique(name2) {
    if (unique_names.has(name2)) {
      parser.error({
        code: "duplicate-attribute",
        message: "Attributes need to be unique"
      }, start);
    }
    unique_names.add(name2);
  }
  if (parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("...")) {
      const expression = (0, import_expression.default)(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      return {
        start,
        end: parser.index,
        type: "Spread",
        expression
      };
    } else {
      const value_start = parser.index;
      const name2 = parser.read_identifier();
      parser.allow_whitespace();
      parser.eat("}", true);
      check_unique(name2);
      return {
        start,
        end: parser.index,
        type: "Attribute",
        name: name2,
        value: [
          {
            start: value_start,
            end: value_start + name2.length,
            type: "AttributeShorthand",
            expression: {
              start: value_start,
              end: value_start + name2.length,
              type: "Identifier",
              name: name2
            }
          }
        ]
      };
    }
  }
  const name = parser.read_until(/[\s=\/>"']/);
  if (!name)
    return null;
  let end = parser.index;
  parser.allow_whitespace();
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    value = read_attribute_value(parser);
    end = parser.index;
  } else if (parser.match_regex(/["']/)) {
    parser.error({
      code: "unexpected-token",
      message: "Expected ="
    }, parser.index);
  }
  check_unique(name);
  return {
    start,
    end,
    type: "Attribute",
    name,
    value
  };
}
function read_attribute_value(parser) {
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  const regex = quote_mark === "'" ? /'/ : quote_mark === '"' ? /"/ : /(\/>|[\s"'=<>`])/;
  const value = read_sequence(parser, () => !!parser.match_regex(regex));
  if (quote_mark)
    parser.index += 1;
  return value;
}
function read_sequence(parser, done) {
  let current_chunk = {
    start: parser.index,
    end: null,
    type: "Text",
    raw: "",
    data: null
  };
  function flush() {
    if (current_chunk.raw) {
      current_chunk.data = (0, import_html.decode_character_references)(current_chunk.raw);
      current_chunk.end = parser.index;
      chunks.push(current_chunk);
    }
  }
  const chunks = [];
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush();
      return chunks;
    } else if (parser.eat("{")) {
      flush();
      parser.allow_whitespace();
      const expression = (0, import_expression.default)(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      chunks.push({
        start: index,
        end: parser.index,
        type: "MustacheTag",
        expression
      });
      current_chunk = {
        start: parser.index,
        end: null,
        type: "Text",
        raw: "",
        data: null
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  parser.error({
    code: "unexpected-eof",
    message: "Unexpected end of input"
  });
}
module.exports = __toCommonJS(tag_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  read_sequence
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL3BhcnNlL3N0YXRlL3RhZy50cyJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQSx3QkFBNEI7QUFDNUIsbUJBQXVCO0FBQ3ZCLGtCQUFpRTtBQUNqRSxtQkFBd0I7QUFHeEIsd0JBQXVCO0FBQ3ZCLGtCQUFpQjtBQUNqQixzQkFBdUM7QUFFdkMsTUFBTSxpQkFBaUI7QUFFdkIsTUFBTSxZQUFZLG9CQUFJLElBQUk7QUFBQSxFQUN6QixDQUFDLGNBQWMsTUFBTTtBQUFBLEVBQ3JCLENBQUMsSUFBSSxjQUFjO0FBSXBCLENBQUM7QUFFRCxNQUFNLGtCQUFrQixNQUFNLEtBQUssVUFBVSxLQUFLLENBQUM7QUFFbkQsTUFBTSxXQUFXLG9CQUFJLElBQUk7QUFBQSxFQVN4QjtBQUFBLElBQ0M7QUFBQSxJQUNBO0FBQUEsTUFDQyxNQUFNO0FBQUEsTUFDTixVQUFVO0FBQUEsSUFDWDtBQUFBLEVBQ0Q7QUFDRCxDQUFDO0FBRUQsTUFBTSxPQUFPO0FBQ2IsTUFBTSxZQUFZO0FBQ2xCLE1BQU0sT0FBTztBQUNiLE1BQU0sT0FBTztBQUNiLE1BQU0saUJBQWlCO0FBRXZCLHdCQUF3QixPQUFPO0FBQzlCLE1BQUksSUFBSSxNQUFNO0FBQ2QsU0FBTyxLQUFLO0FBQ1gsVUFBTSxFQUFFLFNBQVMsTUFBTTtBQUN2QixRQUFJLFNBQVM7QUFBUSxhQUFPO0FBQzVCLFFBQUksU0FBUyxhQUFhLFNBQVM7QUFBbUIsYUFBTztBQUFBLEVBQzlEO0FBQ0EsU0FBTztBQUNSO0FBRWUsYUFBYSxRQUFnQjtBQUMzQyxRQUFNLFFBQVEsT0FBTztBQUVyQixNQUFJLFNBQVMsT0FBTyxRQUFRO0FBRTVCLE1BQUksT0FBTyxJQUFJLEtBQUssR0FBRztBQUN0QixVQUFNLE9BQU8sT0FBTyxXQUFXLEtBQUs7QUFDcEMsV0FBTyxJQUFJLE9BQU8sTUFBTSxxQ0FBcUM7QUFF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
